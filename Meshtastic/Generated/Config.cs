// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: meshtastic/config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Meshtastic.Protobufs {

  /// <summary>Holder for reflection information generated from meshtastic/config.proto</summary>
  public static partial class ConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for meshtastic/config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdtZXNodGFzdGljL2NvbmZpZy5wcm90bxIKbWVzaHRhc3RpYxoabWVzaHRh",
            "c3RpYy9kZXZpY2VfdWkucHJvdG8imSgKBkNvbmZpZxIxCgZkZXZpY2UYASAB",
            "KAsyHy5tZXNodGFzdGljLkNvbmZpZy5EZXZpY2VDb25maWdIABI1Cghwb3Np",
            "dGlvbhgCIAEoCzIhLm1lc2h0YXN0aWMuQ29uZmlnLlBvc2l0aW9uQ29uZmln",
            "SAASLwoFcG93ZXIYAyABKAsyHi5tZXNodGFzdGljLkNvbmZpZy5Qb3dlckNv",
            "bmZpZ0gAEjMKB25ldHdvcmsYBCABKAsyIC5tZXNodGFzdGljLkNvbmZpZy5O",
            "ZXR3b3JrQ29uZmlnSAASMwoHZGlzcGxheRgFIAEoCzIgLm1lc2h0YXN0aWMu",
            "Q29uZmlnLkRpc3BsYXlDb25maWdIABItCgRsb3JhGAYgASgLMh0ubWVzaHRh",
            "c3RpYy5Db25maWcuTG9SYUNvbmZpZ0gAEjcKCWJsdWV0b290aBgHIAEoCzIi",
            "Lm1lc2h0YXN0aWMuQ29uZmlnLkJsdWV0b290aENvbmZpZ0gAEjUKCHNlY3Vy",
            "aXR5GAggASgLMiEubWVzaHRhc3RpYy5Db25maWcuU2VjdXJpdHlDb25maWdI",
            "ABI5CgpzZXNzaW9ua2V5GAkgASgLMiMubWVzaHRhc3RpYy5Db25maWcuU2Vz",
            "c2lvbmtleUNvbmZpZ0gAEi8KCWRldmljZV91aRgKIAEoCzIaLm1lc2h0YXN0",
            "aWMuRGV2aWNlVUlDb25maWdIABrMBgoMRGV2aWNlQ29uZmlnEjIKBHJvbGUY",
            "ASABKA4yJC5tZXNodGFzdGljLkNvbmZpZy5EZXZpY2VDb25maWcuUm9sZRIa",
            "Cg5zZXJpYWxfZW5hYmxlZBgCIAEoCEICGAESEwoLYnV0dG9uX2dwaW8YBCAB",
            "KA0SEwoLYnV6emVyX2dwaW8YBSABKA0SSQoQcmVicm9hZGNhc3RfbW9kZRgG",
            "IAEoDjIvLm1lc2h0YXN0aWMuQ29uZmlnLkRldmljZUNvbmZpZy5SZWJyb2Fk",
            "Y2FzdE1vZGUSIAoYbm9kZV9pbmZvX2Jyb2FkY2FzdF9zZWNzGAcgASgNEiIK",
            "GmRvdWJsZV90YXBfYXNfYnV0dG9uX3ByZXNzGAggASgIEhYKCmlzX21hbmFn",
            "ZWQYCSABKAhCAhgBEhwKFGRpc2FibGVfdHJpcGxlX2NsaWNrGAogASgIEg0K",
            "BXR6ZGVmGAsgASgJEh4KFmxlZF9oZWFydGJlYXRfZGlzYWJsZWQYDCABKAgS",
            "PwoLYnV6emVyX21vZGUYDSABKA4yKi5tZXNodGFzdGljLkNvbmZpZy5EZXZp",
            "Y2VDb25maWcuQnV6emVyTW9kZSK/AQoEUm9sZRIKCgZDTElFTlQQABIPCgtD",
            "TElFTlRfTVVURRABEgoKBlJPVVRFUhACEhUKDVJPVVRFUl9DTElFTlQQAxoC",
            "CAESDAoIUkVQRUFURVIQBBILCgdUUkFDS0VSEAUSCgoGU0VOU09SEAYSBwoD",
            "VEFLEAcSEQoNQ0xJRU5UX0hJRERFThAIEhIKDkxPU1RfQU5EX0ZPVU5EEAkS",
            "DwoLVEFLX1RSQUNLRVIQChIPCgtST1VURVJfTEFURRALInMKD1JlYnJvYWRj",
            "YXN0TW9kZRIHCgNBTEwQABIVChFBTExfU0tJUF9ERUNPRElORxABEg4KCkxP",
            "Q0FMX09OTFkQAhIOCgpLTk9XTl9PTkxZEAMSCAoETk9ORRAEEhYKEkNPUkVf",
            "UE9SVE5VTVNfT05MWRAFIlQKCkJ1enplck1vZGUSDwoLQUxMX0VOQUJMRUQQ",
            "ABIMCghESVNBQkxFRBABEhYKEk5PVElGSUNBVElPTlNfT05MWRACEg8KC1NZ",
            "U1RFTV9PTkxZEAMakQUKDlBvc2l0aW9uQ29uZmlnEh8KF3Bvc2l0aW9uX2Jy",
            "b2FkY2FzdF9zZWNzGAEgASgNEigKIHBvc2l0aW9uX2Jyb2FkY2FzdF9zbWFy",
            "dF9lbmFibGVkGAIgASgIEhYKDmZpeGVkX3Bvc2l0aW9uGAMgASgIEhcKC2dw",
            "c19lbmFibGVkGAQgASgIQgIYARIbChNncHNfdXBkYXRlX2ludGVydmFsGAUg",
            "ASgNEhwKEGdwc19hdHRlbXB0X3RpbWUYBiABKA1CAhgBEhYKDnBvc2l0aW9u",
            "X2ZsYWdzGAcgASgNEg8KB3J4X2dwaW8YCCABKA0SDwoHdHhfZ3BpbxgJIAEo",
            "DRIoCiBicm9hZGNhc3Rfc21hcnRfbWluaW11bV9kaXN0YW5jZRgKIAEoDRIt",
            "CiVicm9hZGNhc3Rfc21hcnRfbWluaW11bV9pbnRlcnZhbF9zZWNzGAsgASgN",
            "EhMKC2dwc19lbl9ncGlvGAwgASgNEjsKCGdwc19tb2RlGA0gASgOMikubWVz",
            "aHRhc3RpYy5Db25maWcuUG9zaXRpb25Db25maWcuR3BzTW9kZSKrAQoNUG9z",
            "aXRpb25GbGFncxIJCgVVTlNFVBAAEgwKCEFMVElUVURFEAESEAoMQUxUSVRV",
            "REVfTVNMEAISFgoSR0VPSURBTF9TRVBBUkFUSU9OEAQSBwoDRE9QEAgSCQoF",
            "SFZET1AQEBINCglTQVRJTlZJRVcQIBIKCgZTRVFfTk8QQBIOCglUSU1FU1RB",
            "TVAQgAESDAoHSEVBRElORxCAAhIKCgVTUEVFRBCABCI1CgdHcHNNb2RlEgwK",
            "CERJU0FCTEVEEAASCwoHRU5BQkxFRBABEg8KC05PVF9QUkVTRU5UEAIahAIK",
            "C1Bvd2VyQ29uZmlnEhcKD2lzX3Bvd2VyX3NhdmluZxgBIAEoCBImCh5vbl9i",
            "YXR0ZXJ5X3NodXRkb3duX2FmdGVyX3NlY3MYAiABKA0SHwoXYWRjX211bHRp",
            "cGxpZXJfb3ZlcnJpZGUYAyABKAISGwoTd2FpdF9ibHVldG9vdGhfc2VjcxgE",
            "IAEoDRIQCghzZHNfc2VjcxgGIAEoDRIPCgdsc19zZWNzGAcgASgNEhUKDW1p",
            "bl93YWtlX3NlY3MYCCABKA0SIgoaZGV2aWNlX2JhdHRlcnlfaW5hX2FkZHJl",
            "c3MYCSABKA0SGAoQcG93ZXJtb25fZW5hYmxlcxggIAEoBBrlAwoNTmV0d29y",
            "a0NvbmZpZxIUCgx3aWZpX2VuYWJsZWQYASABKAgSEQoJd2lmaV9zc2lkGAMg",
            "ASgJEhAKCHdpZmlfcHNrGAQgASgJEhIKCm50cF9zZXJ2ZXIYBSABKAkSEwoL",
            "ZXRoX2VuYWJsZWQYBiABKAgSQgoMYWRkcmVzc19tb2RlGAcgASgOMiwubWVz",
            "aHRhc3RpYy5Db25maWcuTmV0d29ya0NvbmZpZy5BZGRyZXNzTW9kZRJACgtp",
            "cHY0X2NvbmZpZxgIIAEoCzIrLm1lc2h0YXN0aWMuQ29uZmlnLk5ldHdvcmtD",
            "b25maWcuSXBWNENvbmZpZxIWCg5yc3lzbG9nX3NlcnZlchgJIAEoCRIZChFl",
            "bmFibGVkX3Byb3RvY29scxgKIAEoDRIUCgxpcHY2X2VuYWJsZWQYCyABKAga",
            "RgoKSXBWNENvbmZpZxIKCgJpcBgBIAEoBxIPCgdnYXRld2F5GAIgASgHEg4K",
            "BnN1Ym5ldBgDIAEoBxILCgNkbnMYBCABKAciIwoLQWRkcmVzc01vZGUSCAoE",
            "REhDUBAAEgoKBlNUQVRJQxABIjQKDVByb3RvY29sRmxhZ3MSEAoMTk9fQlJP",
            "QURDQVNUEAASEQoNVURQX0JST0FEQ0FTVBABGvwHCg1EaXNwbGF5Q29uZmln",
            "EhYKDnNjcmVlbl9vbl9zZWNzGAEgASgNEkgKCmdwc19mb3JtYXQYAiABKA4y",
            "NC5tZXNodGFzdGljLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkdwc0Nvb3JkaW5h",
            "dGVGb3JtYXQSIQoZYXV0b19zY3JlZW5fY2Fyb3VzZWxfc2VjcxgDIAEoDRIZ",
            "ChFjb21wYXNzX25vcnRoX3RvcBgEIAEoCBITCgtmbGlwX3NjcmVlbhgFIAEo",
            "CBI8CgV1bml0cxgGIAEoDjItLm1lc2h0YXN0aWMuQ29uZmlnLkRpc3BsYXlD",
            "b25maWcuRGlzcGxheVVuaXRzEjcKBG9sZWQYByABKA4yKS5tZXNodGFzdGlj",
            "LkNvbmZpZy5EaXNwbGF5Q29uZmlnLk9sZWRUeXBlEkEKC2Rpc3BsYXltb2Rl",
            "GAggASgOMiwubWVzaHRhc3RpYy5Db25maWcuRGlzcGxheUNvbmZpZy5EaXNw",
            "bGF5TW9kZRIUCgxoZWFkaW5nX2JvbGQYCSABKAgSHQoVd2FrZV9vbl90YXBf",
            "b3JfbW90aW9uGAogASgIElAKE2NvbXBhc3Nfb3JpZW50YXRpb24YCyABKA4y",
            "My5tZXNodGFzdGljLkNvbmZpZy5EaXNwbGF5Q29uZmlnLkNvbXBhc3NPcmll",
            "bnRhdGlvbhIVCg11c2VfMTJoX2Nsb2NrGAwgASgIIk0KE0dwc0Nvb3JkaW5h",
            "dGVGb3JtYXQSBwoDREVDEAASBwoDRE1TEAESBwoDVVRNEAISCAoETUdSUxAD",
            "EgcKA09MQxAEEggKBE9TR1IQBSIoCgxEaXNwbGF5VW5pdHMSCgoGTUVUUklD",
            "EAASDAoISU1QRVJJQUwQASJlCghPbGVkVHlwZRINCglPTEVEX0FVVE8QABIQ",
            "CgxPTEVEX1NTRDEzMDYQARIPCgtPTEVEX1NIMTEwNhACEg8KC09MRURfU0gx",
            "MTA3EAMSFgoST0xFRF9TSDExMDdfMTI4XzY0EAQiQQoLRGlzcGxheU1vZGUS",
            "CwoHREVGQVVMVBAAEgwKCFRXT0NPTE9SEAESDAoISU5WRVJURUQQAhIJCgVD",
            "T0xPUhADIroBChJDb21wYXNzT3JpZW50YXRpb24SDQoJREVHUkVFU18wEAAS",
            "DgoKREVHUkVFU185MBABEg8KC0RFR1JFRVNfMTgwEAISDwoLREVHUkVFU18y",
            "NzAQAxIWChJERUdSRUVTXzBfSU5WRVJURUQQBBIXChNERUdSRUVTXzkwX0lO",
            "VkVSVEVEEAUSGAoUREVHUkVFU18xODBfSU5WRVJURUQQBhIYChRERUdSRUVT",
            "XzI3MF9JTlZFUlRFRBAHGp0HCgpMb1JhQ29uZmlnEhIKCnVzZV9wcmVzZXQY",
            "ASABKAgSPwoMbW9kZW1fcHJlc2V0GAIgASgOMikubWVzaHRhc3RpYy5Db25m",
            "aWcuTG9SYUNvbmZpZy5Nb2RlbVByZXNldBIRCgliYW5kd2lkdGgYAyABKA0S",
            "FQoNc3ByZWFkX2ZhY3RvchgEIAEoDRITCgtjb2RpbmdfcmF0ZRgFIAEoDRIY",
            "ChBmcmVxdWVuY3lfb2Zmc2V0GAYgASgCEjgKBnJlZ2lvbhgHIAEoDjIoLm1l",
            "c2h0YXN0aWMuQ29uZmlnLkxvUmFDb25maWcuUmVnaW9uQ29kZRIRCglob3Bf",
            "bGltaXQYCCABKA0SEgoKdHhfZW5hYmxlZBgJIAEoCBIQCgh0eF9wb3dlchgK",
            "IAEoBRITCgtjaGFubmVsX251bRgLIAEoDRIbChNvdmVycmlkZV9kdXR5X2N5",
            "Y2xlGAwgASgIEh4KFnN4MTI2eF9yeF9ib29zdGVkX2dhaW4YDSABKAgSGgoS",
            "b3ZlcnJpZGVfZnJlcXVlbmN5GA4gASgCEhcKD3BhX2Zhbl9kaXNhYmxlZBgP",
            "IAEoCBIXCg9pZ25vcmVfaW5jb21pbmcYZyADKA0SEwoLaWdub3JlX21xdHQY",
            "aCABKAgSGQoRY29uZmlnX29rX3RvX21xdHQYaSABKAgi8QEKClJlZ2lvbkNv",
            "ZGUSCQoFVU5TRVQQABIGCgJVUxABEgoKBkVVXzQzMxACEgoKBkVVXzg2OBAD",
            "EgYKAkNOEAQSBgoCSlAQBRIHCgNBTloQBhIGCgJLUhAHEgYKAlRXEAgSBgoC",
            "UlUQCRIGCgJJThAKEgoKBk5aXzg2NRALEgYKAlRIEAwSCwoHTE9SQV8yNBAN",
            "EgoKBlVBXzQzMxAOEgoKBlVBXzg2OBAPEgoKBk1ZXzQzMxAQEgoKBk1ZXzkx",
            "ORAREgoKBlNHXzkyMxASEgoKBlBIXzQzMxATEgoKBlBIXzg2OBAUEgoKBlBI",
            "XzkxNRAVIqkBCgtNb2RlbVByZXNldBINCglMT05HX0ZBU1QQABINCglMT05H",
            "X1NMT1cQARIWCg5WRVJZX0xPTkdfU0xPVxACGgIIARIPCgtNRURJVU1fU0xP",
            "VxADEg8KC01FRElVTV9GQVNUEAQSDgoKU0hPUlRfU0xPVxAFEg4KClNIT1JU",
            "X0ZBU1QQBhIRCg1MT05HX01PREVSQVRFEAcSDwoLU0hPUlRfVFVSQk8QCBqt",
            "AQoPQmx1ZXRvb3RoQ29uZmlnEg8KB2VuYWJsZWQYASABKAgSPAoEbW9kZRgC",
            "IAEoDjIuLm1lc2h0YXN0aWMuQ29uZmlnLkJsdWV0b290aENvbmZpZy5QYWly",
            "aW5nTW9kZRIRCglmaXhlZF9waW4YAyABKA0iOAoLUGFpcmluZ01vZGUSDgoK",
            "UkFORE9NX1BJThAAEg0KCUZJWEVEX1BJThABEgoKBk5PX1BJThACGrYBCg5T",
            "ZWN1cml0eUNvbmZpZxISCgpwdWJsaWNfa2V5GAEgASgMEhMKC3ByaXZhdGVf",
            "a2V5GAIgASgMEhEKCWFkbWluX2tleRgDIAMoDBISCgppc19tYW5hZ2VkGAQg",
            "ASgIEhYKDnNlcmlhbF9lbmFibGVkGAUgASgIEh0KFWRlYnVnX2xvZ19hcGlf",
            "ZW5hYmxlZBgGIAEoCBIdChVhZG1pbl9jaGFubmVsX2VuYWJsZWQYCCABKAga",
            "EgoQU2Vzc2lvbmtleUNvbmZpZ0IRCg9wYXlsb2FkX3ZhcmlhbnRCYQoTY29t",
            "LmdlZWtzdmlsbGUubWVzaEIMQ29uZmlnUHJvdG9zWiJnaXRodWIuY29tL21l",
            "c2h0YXN0aWMvZ28vZ2VuZXJhdGVkqgIUTWVzaHRhc3RpYy5Qcm90b2J1ZnO6",
            "AgBiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Meshtastic.Protobufs.DeviceUiReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config), global::Meshtastic.Protobufs.Config.Parser, new[]{ "Device", "Position", "Power", "Network", "Display", "Lora", "Bluetooth", "Security", "Sessionkey", "DeviceUi" }, new[]{ "PayloadVariant" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig), global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Parser, new[]{ "Role", "SerialEnabled", "ButtonGpio", "BuzzerGpio", "RebroadcastMode", "NodeInfoBroadcastSecs", "DoubleTapAsButtonPress", "IsManaged", "DisableTripleClick", "Tzdef", "LedHeartbeatDisabled", "BuzzerMode" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role), typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode), typeof(global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.PositionConfig), global::Meshtastic.Protobufs.Config.Types.PositionConfig.Parser, new[]{ "PositionBroadcastSecs", "PositionBroadcastSmartEnabled", "FixedPosition", "GpsEnabled", "GpsUpdateInterval", "GpsAttemptTime", "PositionFlags", "RxGpio", "TxGpio", "BroadcastSmartMinimumDistance", "BroadcastSmartMinimumIntervalSecs", "GpsEnGpio", "GpsMode" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.PositionFlags), typeof(global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.PowerConfig), global::Meshtastic.Protobufs.Config.Types.PowerConfig.Parser, new[]{ "IsPowerSaving", "OnBatteryShutdownAfterSecs", "AdcMultiplierOverride", "WaitBluetoothSecs", "SdsSecs", "LsSecs", "MinWakeSecs", "DeviceBatteryInaAddress", "PowermonEnables" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig), global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Parser, new[]{ "WifiEnabled", "WifiSsid", "WifiPsk", "NtpServer", "EthEnabled", "AddressMode", "Ipv4Config", "RsyslogServer", "EnabledProtocols", "Ipv6Enabled" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode), typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.ProtocolFlags) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config), global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config.Parser, new[]{ "Ip", "Gateway", "Subnet", "Dns" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig), global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Parser, new[]{ "ScreenOnSecs", "GpsFormat", "AutoScreenCarouselSecs", "CompassNorthTop", "FlipScreen", "Units", "Oled", "Displaymode", "HeadingBold", "WakeOnTapOrMotion", "CompassOrientation", "Use12HClock" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode), typeof(global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig), global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Parser, new[]{ "UsePreset", "ModemPreset", "Bandwidth", "SpreadFactor", "CodingRate", "FrequencyOffset", "Region", "HopLimit", "TxEnabled", "TxPower", "ChannelNum", "OverrideDutyCycle", "Sx126XRxBoostedGain", "OverrideFrequency", "PaFanDisabled", "IgnoreIncoming", "IgnoreMqtt", "ConfigOkToMqtt" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode), typeof(global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.BluetoothConfig), global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Parser, new[]{ "Enabled", "Mode", "FixedPin" }, null, new[]{ typeof(global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.SecurityConfig), global::Meshtastic.Protobufs.Config.Types.SecurityConfig.Parser, new[]{ "PublicKey", "PrivateKey", "AdminKey", "IsManaged", "SerialEnabled", "DebugLogApiEnabled", "AdminChannelEnabled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig), global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig.Parser, null, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Config : pb::IMessage<Config>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Config> _parser = new pb::MessageParser<Config>(() => new Config());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Config> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Meshtastic.Protobufs.ConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config(Config other) : this() {
      switch (other.PayloadVariantCase) {
        case PayloadVariantOneofCase.Device:
          Device = other.Device.Clone();
          break;
        case PayloadVariantOneofCase.Position:
          Position = other.Position.Clone();
          break;
        case PayloadVariantOneofCase.Power:
          Power = other.Power.Clone();
          break;
        case PayloadVariantOneofCase.Network:
          Network = other.Network.Clone();
          break;
        case PayloadVariantOneofCase.Display:
          Display = other.Display.Clone();
          break;
        case PayloadVariantOneofCase.Lora:
          Lora = other.Lora.Clone();
          break;
        case PayloadVariantOneofCase.Bluetooth:
          Bluetooth = other.Bluetooth.Clone();
          break;
        case PayloadVariantOneofCase.Security:
          Security = other.Security.Clone();
          break;
        case PayloadVariantOneofCase.Sessionkey:
          Sessionkey = other.Sessionkey.Clone();
          break;
        case PayloadVariantOneofCase.DeviceUi:
          DeviceUi = other.DeviceUi.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Config Clone() {
      return new Config(this);
    }

    /// <summary>Field number for the "device" field.</summary>
    public const int DeviceFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.DeviceConfig Device {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Device ? (global::Meshtastic.Protobufs.Config.Types.DeviceConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Device;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.PositionConfig Position {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Position ? (global::Meshtastic.Protobufs.Config.Types.PositionConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Position;
      }
    }

    /// <summary>Field number for the "power" field.</summary>
    public const int PowerFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.PowerConfig Power {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Power ? (global::Meshtastic.Protobufs.Config.Types.PowerConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Power;
      }
    }

    /// <summary>Field number for the "network" field.</summary>
    public const int NetworkFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.NetworkConfig Network {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Network ? (global::Meshtastic.Protobufs.Config.Types.NetworkConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Network;
      }
    }

    /// <summary>Field number for the "display" field.</summary>
    public const int DisplayFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.DisplayConfig Display {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Display ? (global::Meshtastic.Protobufs.Config.Types.DisplayConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Display;
      }
    }

    /// <summary>Field number for the "lora" field.</summary>
    public const int LoraFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.LoRaConfig Lora {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Lora ? (global::Meshtastic.Protobufs.Config.Types.LoRaConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Lora;
      }
    }

    /// <summary>Field number for the "bluetooth" field.</summary>
    public const int BluetoothFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.BluetoothConfig Bluetooth {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth ? (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Bluetooth;
      }
    }

    /// <summary>Field number for the "security" field.</summary>
    public const int SecurityFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.SecurityConfig Security {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Security ? (global::Meshtastic.Protobufs.Config.Types.SecurityConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Security;
      }
    }

    /// <summary>Field number for the "sessionkey" field.</summary>
    public const int SessionkeyFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig Sessionkey {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey ? (global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.Sessionkey;
      }
    }

    /// <summary>Field number for the "device_ui" field.</summary>
    public const int DeviceUiFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Meshtastic.Protobufs.DeviceUIConfig DeviceUi {
      get { return payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi ? (global::Meshtastic.Protobufs.DeviceUIConfig) payloadVariant_ : null; }
      set {
        payloadVariant_ = value;
        payloadVariantCase_ = value == null ? PayloadVariantOneofCase.None : PayloadVariantOneofCase.DeviceUi;
      }
    }

    private object payloadVariant_;
    /// <summary>Enum of possible cases for the "payload_variant" oneof.</summary>
    public enum PayloadVariantOneofCase {
      None = 0,
      Device = 1,
      Position = 2,
      Power = 3,
      Network = 4,
      Display = 5,
      Lora = 6,
      Bluetooth = 7,
      Security = 8,
      Sessionkey = 9,
      DeviceUi = 10,
    }
    private PayloadVariantOneofCase payloadVariantCase_ = PayloadVariantOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PayloadVariantOneofCase PayloadVariantCase {
      get { return payloadVariantCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPayloadVariant() {
      payloadVariantCase_ = PayloadVariantOneofCase.None;
      payloadVariant_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Config);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Config other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Device, other.Device)) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Power, other.Power)) return false;
      if (!object.Equals(Network, other.Network)) return false;
      if (!object.Equals(Display, other.Display)) return false;
      if (!object.Equals(Lora, other.Lora)) return false;
      if (!object.Equals(Bluetooth, other.Bluetooth)) return false;
      if (!object.Equals(Security, other.Security)) return false;
      if (!object.Equals(Sessionkey, other.Sessionkey)) return false;
      if (!object.Equals(DeviceUi, other.DeviceUi)) return false;
      if (PayloadVariantCase != other.PayloadVariantCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) hash ^= Device.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) hash ^= Position.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) hash ^= Power.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) hash ^= Network.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) hash ^= Display.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) hash ^= Lora.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) hash ^= Bluetooth.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Security) hash ^= Security.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) hash ^= Sessionkey.GetHashCode();
      if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) hash ^= DeviceUi.GetHashCode();
      hash ^= (int) payloadVariantCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        output.WriteRawTag(10);
        output.WriteMessage(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        output.WriteRawTag(26);
        output.WriteMessage(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        output.WriteRawTag(34);
        output.WriteMessage(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        output.WriteRawTag(42);
        output.WriteMessage(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        output.WriteRawTag(50);
        output.WriteMessage(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        output.WriteRawTag(58);
        output.WriteMessage(Bluetooth);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Security) {
        output.WriteRawTag(66);
        output.WriteMessage(Security);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) {
        output.WriteRawTag(74);
        output.WriteMessage(Sessionkey);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) {
        output.WriteRawTag(82);
        output.WriteMessage(DeviceUi);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        output.WriteRawTag(10);
        output.WriteMessage(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        output.WriteRawTag(26);
        output.WriteMessage(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        output.WriteRawTag(34);
        output.WriteMessage(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        output.WriteRawTag(42);
        output.WriteMessage(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        output.WriteRawTag(50);
        output.WriteMessage(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        output.WriteRawTag(58);
        output.WriteMessage(Bluetooth);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Security) {
        output.WriteRawTag(66);
        output.WriteMessage(Security);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) {
        output.WriteRawTag(74);
        output.WriteMessage(Sessionkey);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) {
        output.WriteRawTag(82);
        output.WriteMessage(DeviceUi);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Device);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Power);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Network);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Display);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lora);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Bluetooth);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Security) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Security);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sessionkey);
      }
      if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceUi);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Config other) {
      if (other == null) {
        return;
      }
      switch (other.PayloadVariantCase) {
        case PayloadVariantOneofCase.Device:
          if (Device == null) {
            Device = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
          }
          Device.MergeFrom(other.Device);
          break;
        case PayloadVariantOneofCase.Position:
          if (Position == null) {
            Position = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
          }
          Position.MergeFrom(other.Position);
          break;
        case PayloadVariantOneofCase.Power:
          if (Power == null) {
            Power = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
          }
          Power.MergeFrom(other.Power);
          break;
        case PayloadVariantOneofCase.Network:
          if (Network == null) {
            Network = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
          }
          Network.MergeFrom(other.Network);
          break;
        case PayloadVariantOneofCase.Display:
          if (Display == null) {
            Display = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
          }
          Display.MergeFrom(other.Display);
          break;
        case PayloadVariantOneofCase.Lora:
          if (Lora == null) {
            Lora = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
          }
          Lora.MergeFrom(other.Lora);
          break;
        case PayloadVariantOneofCase.Bluetooth:
          if (Bluetooth == null) {
            Bluetooth = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
          }
          Bluetooth.MergeFrom(other.Bluetooth);
          break;
        case PayloadVariantOneofCase.Security:
          if (Security == null) {
            Security = new global::Meshtastic.Protobufs.Config.Types.SecurityConfig();
          }
          Security.MergeFrom(other.Security);
          break;
        case PayloadVariantOneofCase.Sessionkey:
          if (Sessionkey == null) {
            Sessionkey = new global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig();
          }
          Sessionkey.MergeFrom(other.Sessionkey);
          break;
        case PayloadVariantOneofCase.DeviceUi:
          if (DeviceUi == null) {
            DeviceUi = new global::Meshtastic.Protobufs.DeviceUIConfig();
          }
          DeviceUi.MergeFrom(other.DeviceUi);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Meshtastic.Protobufs.Config.Types.DeviceConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
              subBuilder.MergeFrom(Device);
            }
            input.ReadMessage(subBuilder);
            Device = subBuilder;
            break;
          }
          case 18: {
            global::Meshtastic.Protobufs.Config.Types.PositionConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
              subBuilder.MergeFrom(Position);
            }
            input.ReadMessage(subBuilder);
            Position = subBuilder;
            break;
          }
          case 26: {
            global::Meshtastic.Protobufs.Config.Types.PowerConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
              subBuilder.MergeFrom(Power);
            }
            input.ReadMessage(subBuilder);
            Power = subBuilder;
            break;
          }
          case 34: {
            global::Meshtastic.Protobufs.Config.Types.NetworkConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
              subBuilder.MergeFrom(Network);
            }
            input.ReadMessage(subBuilder);
            Network = subBuilder;
            break;
          }
          case 42: {
            global::Meshtastic.Protobufs.Config.Types.DisplayConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
              subBuilder.MergeFrom(Display);
            }
            input.ReadMessage(subBuilder);
            Display = subBuilder;
            break;
          }
          case 50: {
            global::Meshtastic.Protobufs.Config.Types.LoRaConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
              subBuilder.MergeFrom(Lora);
            }
            input.ReadMessage(subBuilder);
            Lora = subBuilder;
            break;
          }
          case 58: {
            global::Meshtastic.Protobufs.Config.Types.BluetoothConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
              subBuilder.MergeFrom(Bluetooth);
            }
            input.ReadMessage(subBuilder);
            Bluetooth = subBuilder;
            break;
          }
          case 66: {
            global::Meshtastic.Protobufs.Config.Types.SecurityConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.SecurityConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Security) {
              subBuilder.MergeFrom(Security);
            }
            input.ReadMessage(subBuilder);
            Security = subBuilder;
            break;
          }
          case 74: {
            global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) {
              subBuilder.MergeFrom(Sessionkey);
            }
            input.ReadMessage(subBuilder);
            Sessionkey = subBuilder;
            break;
          }
          case 82: {
            global::Meshtastic.Protobufs.DeviceUIConfig subBuilder = new global::Meshtastic.Protobufs.DeviceUIConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) {
              subBuilder.MergeFrom(DeviceUi);
            }
            input.ReadMessage(subBuilder);
            DeviceUi = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Meshtastic.Protobufs.Config.Types.DeviceConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DeviceConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Device) {
              subBuilder.MergeFrom(Device);
            }
            input.ReadMessage(subBuilder);
            Device = subBuilder;
            break;
          }
          case 18: {
            global::Meshtastic.Protobufs.Config.Types.PositionConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PositionConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Position) {
              subBuilder.MergeFrom(Position);
            }
            input.ReadMessage(subBuilder);
            Position = subBuilder;
            break;
          }
          case 26: {
            global::Meshtastic.Protobufs.Config.Types.PowerConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.PowerConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Power) {
              subBuilder.MergeFrom(Power);
            }
            input.ReadMessage(subBuilder);
            Power = subBuilder;
            break;
          }
          case 34: {
            global::Meshtastic.Protobufs.Config.Types.NetworkConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Network) {
              subBuilder.MergeFrom(Network);
            }
            input.ReadMessage(subBuilder);
            Network = subBuilder;
            break;
          }
          case 42: {
            global::Meshtastic.Protobufs.Config.Types.DisplayConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.DisplayConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Display) {
              subBuilder.MergeFrom(Display);
            }
            input.ReadMessage(subBuilder);
            Display = subBuilder;
            break;
          }
          case 50: {
            global::Meshtastic.Protobufs.Config.Types.LoRaConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.LoRaConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Lora) {
              subBuilder.MergeFrom(Lora);
            }
            input.ReadMessage(subBuilder);
            Lora = subBuilder;
            break;
          }
          case 58: {
            global::Meshtastic.Protobufs.Config.Types.BluetoothConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.BluetoothConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Bluetooth) {
              subBuilder.MergeFrom(Bluetooth);
            }
            input.ReadMessage(subBuilder);
            Bluetooth = subBuilder;
            break;
          }
          case 66: {
            global::Meshtastic.Protobufs.Config.Types.SecurityConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.SecurityConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Security) {
              subBuilder.MergeFrom(Security);
            }
            input.ReadMessage(subBuilder);
            Security = subBuilder;
            break;
          }
          case 74: {
            global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig subBuilder = new global::Meshtastic.Protobufs.Config.Types.SessionkeyConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.Sessionkey) {
              subBuilder.MergeFrom(Sessionkey);
            }
            input.ReadMessage(subBuilder);
            Sessionkey = subBuilder;
            break;
          }
          case 82: {
            global::Meshtastic.Protobufs.DeviceUIConfig subBuilder = new global::Meshtastic.Protobufs.DeviceUIConfig();
            if (payloadVariantCase_ == PayloadVariantOneofCase.DeviceUi) {
              subBuilder.MergeFrom(DeviceUi);
            }
            input.ReadMessage(subBuilder);
            DeviceUi = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Config message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///
      /// Configuration
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class DeviceConfig : pb::IMessage<DeviceConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DeviceConfig> _parser = new pb::MessageParser<DeviceConfig>(() => new DeviceConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DeviceConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig(DeviceConfig other) : this() {
          role_ = other.role_;
          serialEnabled_ = other.serialEnabled_;
          buttonGpio_ = other.buttonGpio_;
          buzzerGpio_ = other.buzzerGpio_;
          rebroadcastMode_ = other.rebroadcastMode_;
          nodeInfoBroadcastSecs_ = other.nodeInfoBroadcastSecs_;
          doubleTapAsButtonPress_ = other.doubleTapAsButtonPress_;
          isManaged_ = other.isManaged_;
          disableTripleClick_ = other.disableTripleClick_;
          tzdef_ = other.tzdef_;
          ledHeartbeatDisabled_ = other.ledHeartbeatDisabled_;
          buzzerMode_ = other.buzzerMode_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DeviceConfig Clone() {
          return new DeviceConfig(this);
        }

        /// <summary>Field number for the "role" field.</summary>
        public const int RoleFieldNumber = 1;
        private global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role role_ = global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client;
        /// <summary>
        ///
        /// Sets the role of node
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role Role {
          get { return role_; }
          set {
            role_ = value;
          }
        }

        /// <summary>Field number for the "serial_enabled" field.</summary>
        public const int SerialEnabledFieldNumber = 2;
        private bool serialEnabled_;
        /// <summary>
        ///
        /// Disabling this will disable the SerialConsole by not initilizing the StreamAPI
        /// Moved to SecurityConfig
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SerialEnabled {
          get { return serialEnabled_; }
          set {
            serialEnabled_ = value;
          }
        }

        /// <summary>Field number for the "button_gpio" field.</summary>
        public const int ButtonGpioFieldNumber = 4;
        private uint buttonGpio_;
        /// <summary>
        ///
        /// For boards without a hard wired button, this is the pin number that will be used
        /// Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ButtonGpio {
          get { return buttonGpio_; }
          set {
            buttonGpio_ = value;
          }
        }

        /// <summary>Field number for the "buzzer_gpio" field.</summary>
        public const int BuzzerGpioFieldNumber = 5;
        private uint buzzerGpio_;
        /// <summary>
        ///
        /// For boards without a PWM buzzer, this is the pin number that will be used
        /// Defaults to PIN_BUZZER if defined.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint BuzzerGpio {
          get { return buzzerGpio_; }
          set {
            buzzerGpio_ = value;
          }
        }

        /// <summary>Field number for the "rebroadcast_mode" field.</summary>
        public const int RebroadcastModeFieldNumber = 6;
        private global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode rebroadcastMode_ = global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All;
        /// <summary>
        ///
        /// Sets the role of node
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode RebroadcastMode {
          get { return rebroadcastMode_; }
          set {
            rebroadcastMode_ = value;
          }
        }

        /// <summary>Field number for the "node_info_broadcast_secs" field.</summary>
        public const int NodeInfoBroadcastSecsFieldNumber = 7;
        private uint nodeInfoBroadcastSecs_;
        /// <summary>
        ///
        /// Send our nodeinfo this often
        /// Defaults to 900 Seconds (15 minutes)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint NodeInfoBroadcastSecs {
          get { return nodeInfoBroadcastSecs_; }
          set {
            nodeInfoBroadcastSecs_ = value;
          }
        }

        /// <summary>Field number for the "double_tap_as_button_press" field.</summary>
        public const int DoubleTapAsButtonPressFieldNumber = 8;
        private bool doubleTapAsButtonPress_;
        /// <summary>
        ///
        /// Treat double tap interrupt on supported accelerometers as a button press if set to true
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DoubleTapAsButtonPress {
          get { return doubleTapAsButtonPress_; }
          set {
            doubleTapAsButtonPress_ = value;
          }
        }

        /// <summary>Field number for the "is_managed" field.</summary>
        public const int IsManagedFieldNumber = 9;
        private bool isManaged_;
        /// <summary>
        ///
        /// If true, device is considered to be "managed" by a mesh administrator
        /// Clients should then limit available configuration and administrative options inside the user interface
        /// Moved to SecurityConfig
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsManaged {
          get { return isManaged_; }
          set {
            isManaged_ = value;
          }
        }

        /// <summary>Field number for the "disable_triple_click" field.</summary>
        public const int DisableTripleClickFieldNumber = 10;
        private bool disableTripleClick_;
        /// <summary>
        ///
        /// Disables the triple-press of user button to enable or disable GPS
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DisableTripleClick {
          get { return disableTripleClick_; }
          set {
            disableTripleClick_ = value;
          }
        }

        /// <summary>Field number for the "tzdef" field.</summary>
        public const int TzdefFieldNumber = 11;
        private string tzdef_ = "";
        /// <summary>
        ///
        /// POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Tzdef {
          get { return tzdef_; }
          set {
            tzdef_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "led_heartbeat_disabled" field.</summary>
        public const int LedHeartbeatDisabledFieldNumber = 12;
        private bool ledHeartbeatDisabled_;
        /// <summary>
        ///
        /// If true, disable the default blinking LED (LED_PIN) behavior on the device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool LedHeartbeatDisabled {
          get { return ledHeartbeatDisabled_; }
          set {
            ledHeartbeatDisabled_ = value;
          }
        }

        /// <summary>Field number for the "buzzer_mode" field.</summary>
        public const int BuzzerModeFieldNumber = 13;
        private global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode buzzerMode_ = global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled;
        /// <summary>
        ///
        /// Controls buzzer behavior for audio feedback
        /// Defaults to ENABLED
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode BuzzerMode {
          get { return buzzerMode_; }
          set {
            buzzerMode_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DeviceConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DeviceConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Role != other.Role) return false;
          if (SerialEnabled != other.SerialEnabled) return false;
          if (ButtonGpio != other.ButtonGpio) return false;
          if (BuzzerGpio != other.BuzzerGpio) return false;
          if (RebroadcastMode != other.RebroadcastMode) return false;
          if (NodeInfoBroadcastSecs != other.NodeInfoBroadcastSecs) return false;
          if (DoubleTapAsButtonPress != other.DoubleTapAsButtonPress) return false;
          if (IsManaged != other.IsManaged) return false;
          if (DisableTripleClick != other.DisableTripleClick) return false;
          if (Tzdef != other.Tzdef) return false;
          if (LedHeartbeatDisabled != other.LedHeartbeatDisabled) return false;
          if (BuzzerMode != other.BuzzerMode) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) hash ^= Role.GetHashCode();
          if (SerialEnabled != false) hash ^= SerialEnabled.GetHashCode();
          if (ButtonGpio != 0) hash ^= ButtonGpio.GetHashCode();
          if (BuzzerGpio != 0) hash ^= BuzzerGpio.GetHashCode();
          if (RebroadcastMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All) hash ^= RebroadcastMode.GetHashCode();
          if (NodeInfoBroadcastSecs != 0) hash ^= NodeInfoBroadcastSecs.GetHashCode();
          if (DoubleTapAsButtonPress != false) hash ^= DoubleTapAsButtonPress.GetHashCode();
          if (IsManaged != false) hash ^= IsManaged.GetHashCode();
          if (DisableTripleClick != false) hash ^= DisableTripleClick.GetHashCode();
          if (Tzdef.Length != 0) hash ^= Tzdef.GetHashCode();
          if (LedHeartbeatDisabled != false) hash ^= LedHeartbeatDisabled.GetHashCode();
          if (BuzzerMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled) hash ^= BuzzerMode.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Role);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(SerialEnabled);
          }
          if (ButtonGpio != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(BuzzerGpio);
          }
          if (RebroadcastMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All) {
            output.WriteRawTag(48);
            output.WriteEnum((int) RebroadcastMode);
          }
          if (NodeInfoBroadcastSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(NodeInfoBroadcastSecs);
          }
          if (DoubleTapAsButtonPress != false) {
            output.WriteRawTag(64);
            output.WriteBool(DoubleTapAsButtonPress);
          }
          if (IsManaged != false) {
            output.WriteRawTag(72);
            output.WriteBool(IsManaged);
          }
          if (DisableTripleClick != false) {
            output.WriteRawTag(80);
            output.WriteBool(DisableTripleClick);
          }
          if (Tzdef.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(Tzdef);
          }
          if (LedHeartbeatDisabled != false) {
            output.WriteRawTag(96);
            output.WriteBool(LedHeartbeatDisabled);
          }
          if (BuzzerMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled) {
            output.WriteRawTag(104);
            output.WriteEnum((int) BuzzerMode);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Role);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(SerialEnabled);
          }
          if (ButtonGpio != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(BuzzerGpio);
          }
          if (RebroadcastMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All) {
            output.WriteRawTag(48);
            output.WriteEnum((int) RebroadcastMode);
          }
          if (NodeInfoBroadcastSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(NodeInfoBroadcastSecs);
          }
          if (DoubleTapAsButtonPress != false) {
            output.WriteRawTag(64);
            output.WriteBool(DoubleTapAsButtonPress);
          }
          if (IsManaged != false) {
            output.WriteRawTag(72);
            output.WriteBool(IsManaged);
          }
          if (DisableTripleClick != false) {
            output.WriteRawTag(80);
            output.WriteBool(DisableTripleClick);
          }
          if (Tzdef.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(Tzdef);
          }
          if (LedHeartbeatDisabled != false) {
            output.WriteRawTag(96);
            output.WriteBool(LedHeartbeatDisabled);
          }
          if (BuzzerMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled) {
            output.WriteRawTag(104);
            output.WriteEnum((int) BuzzerMode);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Role);
          }
          if (SerialEnabled != false) {
            size += 1 + 1;
          }
          if (ButtonGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ButtonGpio);
          }
          if (BuzzerGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BuzzerGpio);
          }
          if (RebroadcastMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RebroadcastMode);
          }
          if (NodeInfoBroadcastSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeInfoBroadcastSecs);
          }
          if (DoubleTapAsButtonPress != false) {
            size += 1 + 1;
          }
          if (IsManaged != false) {
            size += 1 + 1;
          }
          if (DisableTripleClick != false) {
            size += 1 + 1;
          }
          if (Tzdef.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Tzdef);
          }
          if (LedHeartbeatDisabled != false) {
            size += 1 + 1;
          }
          if (BuzzerMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BuzzerMode);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DeviceConfig other) {
          if (other == null) {
            return;
          }
          if (other.Role != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role.Client) {
            Role = other.Role;
          }
          if (other.SerialEnabled != false) {
            SerialEnabled = other.SerialEnabled;
          }
          if (other.ButtonGpio != 0) {
            ButtonGpio = other.ButtonGpio;
          }
          if (other.BuzzerGpio != 0) {
            BuzzerGpio = other.BuzzerGpio;
          }
          if (other.RebroadcastMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode.All) {
            RebroadcastMode = other.RebroadcastMode;
          }
          if (other.NodeInfoBroadcastSecs != 0) {
            NodeInfoBroadcastSecs = other.NodeInfoBroadcastSecs;
          }
          if (other.DoubleTapAsButtonPress != false) {
            DoubleTapAsButtonPress = other.DoubleTapAsButtonPress;
          }
          if (other.IsManaged != false) {
            IsManaged = other.IsManaged;
          }
          if (other.DisableTripleClick != false) {
            DisableTripleClick = other.DisableTripleClick;
          }
          if (other.Tzdef.Length != 0) {
            Tzdef = other.Tzdef;
          }
          if (other.LedHeartbeatDisabled != false) {
            LedHeartbeatDisabled = other.LedHeartbeatDisabled;
          }
          if (other.BuzzerMode != global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode.AllEnabled) {
            BuzzerMode = other.BuzzerMode;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Role = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role) input.ReadEnum();
                break;
              }
              case 16: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 32: {
                ButtonGpio = input.ReadUInt32();
                break;
              }
              case 40: {
                BuzzerGpio = input.ReadUInt32();
                break;
              }
              case 48: {
                RebroadcastMode = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode) input.ReadEnum();
                break;
              }
              case 56: {
                NodeInfoBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                DoubleTapAsButtonPress = input.ReadBool();
                break;
              }
              case 72: {
                IsManaged = input.ReadBool();
                break;
              }
              case 80: {
                DisableTripleClick = input.ReadBool();
                break;
              }
              case 90: {
                Tzdef = input.ReadString();
                break;
              }
              case 96: {
                LedHeartbeatDisabled = input.ReadBool();
                break;
              }
              case 104: {
                BuzzerMode = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Role = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.Role) input.ReadEnum();
                break;
              }
              case 16: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 32: {
                ButtonGpio = input.ReadUInt32();
                break;
              }
              case 40: {
                BuzzerGpio = input.ReadUInt32();
                break;
              }
              case 48: {
                RebroadcastMode = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.RebroadcastMode) input.ReadEnum();
                break;
              }
              case 56: {
                NodeInfoBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                DoubleTapAsButtonPress = input.ReadBool();
                break;
              }
              case 72: {
                IsManaged = input.ReadBool();
                break;
              }
              case 80: {
                DisableTripleClick = input.ReadBool();
                break;
              }
              case 90: {
                Tzdef = input.ReadString();
                break;
              }
              case 96: {
                LedHeartbeatDisabled = input.ReadBool();
                break;
              }
              case 104: {
                BuzzerMode = (global::Meshtastic.Protobufs.Config.Types.DeviceConfig.Types.BuzzerMode) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the DeviceConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// Defines the device's role on the Mesh network
          /// </summary>
          public enum Role {
            /// <summary>
            ///
            /// Description: App connected or stand alone messaging device.
            /// Technical Details: Default Role
            /// </summary>
            [pbr::OriginalName("CLIENT")] Client = 0,
            /// <summary>
            ///
            ///  Description: Device that does not forward packets from other devices.
            /// </summary>
            [pbr::OriginalName("CLIENT_MUTE")] ClientMute = 1,
            /// <summary>
            ///
            /// Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
            /// Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
            ///   The wifi radio and the oled screen will be put to sleep.
            ///   This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
            /// </summary>
            [pbr::OriginalName("ROUTER")] Router = 2,
            [global::System.ObsoleteAttribute]
            [pbr::OriginalName("ROUTER_CLIENT")] RouterClient = 3,
            /// <summary>
            ///
            /// Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
            /// Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
            ///   or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
            /// </summary>
            [pbr::OriginalName("REPEATER")] Repeater = 4,
            /// <summary>
            ///
            /// Description: Broadcasts GPS position packets as priority.
            /// Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
            ///   When used in conjunction with power.is_power_saving = true, nodes will wake up,
            ///   send position, and then sleep for position.position_broadcast_secs seconds.
            /// </summary>
            [pbr::OriginalName("TRACKER")] Tracker = 5,
            /// <summary>
            ///
            /// Description: Broadcasts telemetry packets as priority.
            /// Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
            ///   When used in conjunction with power.is_power_saving = true, nodes will wake up,
            ///   send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
            /// </summary>
            [pbr::OriginalName("SENSOR")] Sensor = 6,
            /// <summary>
            ///
            /// Description: Optimized for ATAK system communication and reduces routine broadcasts.
            /// Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
            ///    Turns off many of the routine broadcasts to favor CoT packet stream
            ///    from the Meshtastic ATAK plugin -> IMeshService -> Node
            /// </summary>
            [pbr::OriginalName("TAK")] Tak = 7,
            /// <summary>
            ///
            /// Description: Device that only broadcasts as needed for stealth or power savings.
            /// Technical Details: Used for nodes that "only speak when spoken to"
            ///    Turns all of the routine broadcasts but allows for ad-hoc communication
            ///    Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
            ///    Can be used for clandestine operation or to dramatically reduce airtime / power consumption
            /// </summary>
            [pbr::OriginalName("CLIENT_HIDDEN")] ClientHidden = 8,
            /// <summary>
            ///
            /// Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
            /// Technical Details: Used to automatically send a text message to the mesh
            ///    with the current position of the device on a frequent interval:
            ///    "I'm lost! Position: lat / long"
            /// </summary>
            [pbr::OriginalName("LOST_AND_FOUND")] LostAndFound = 9,
            /// <summary>
            ///
            /// Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
            /// Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
            ///    and automatic TAK PLI (position location information) broadcasts.
            ///    Uses position module configuration to determine TAK PLI broadcast interval.
            /// </summary>
            [pbr::OriginalName("TAK_TRACKER")] TakTracker = 10,
            /// <summary>
            ///
            /// Description: Will always rebroadcast packets, but will do so after all other modes.
            /// Technical Details: Used for router nodes that are intended to provide additional coverage
            ///    in areas not already covered by other routers, or to bridge around problematic terrain,
            ///    but should not be given priority over other routers in order to avoid unnecessaraily
            ///    consuming hops.
            /// </summary>
            [pbr::OriginalName("ROUTER_LATE")] RouterLate = 11,
          }

          /// <summary>
          ///
          /// Defines the device's behavior for how messages are rebroadcast
          /// </summary>
          public enum RebroadcastMode {
            /// <summary>
            ///
            /// Default behavior.
            /// Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
            /// </summary>
            [pbr::OriginalName("ALL")] All = 0,
            /// <summary>
            ///
            /// Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
            /// Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
            /// </summary>
            [pbr::OriginalName("ALL_SKIP_DECODING")] AllSkipDecoding = 1,
            /// <summary>
            ///
            /// Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
            /// Only rebroadcasts message on the nodes local primary / secondary channels.
            /// </summary>
            [pbr::OriginalName("LOCAL_ONLY")] LocalOnly = 2,
            /// <summary>
            ///
            /// Ignores observed messages from foreign meshes like LOCAL_ONLY,
            /// but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
            /// </summary>
            [pbr::OriginalName("KNOWN_ONLY")] KnownOnly = 3,
            /// <summary>
            ///
            /// Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
            /// </summary>
            [pbr::OriginalName("NONE")] None = 4,
            /// <summary>
            ///
            /// Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
            /// Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
            /// </summary>
            [pbr::OriginalName("CORE_PORTNUMS_ONLY")] CorePortnumsOnly = 5,
          }

          /// <summary>
          ///
          /// Defines buzzer behavior for audio feedback
          /// </summary>
          public enum BuzzerMode {
            /// <summary>
            ///
            /// Default behavior.
            /// Buzzer is enabled for all audio feedback including button presses and alerts.
            /// </summary>
            [pbr::OriginalName("ALL_ENABLED")] AllEnabled = 0,
            /// <summary>
            ///
            /// Disabled.
            /// All buzzer audio feedback is disabled.
            /// </summary>
            [pbr::OriginalName("DISABLED")] Disabled = 1,
            /// <summary>
            ///
            /// Notifications Only.
            /// Buzzer is enabled only for notifications and alerts, but not for button presses.
            /// External notification config determines the specifics of the notification behavior.
            /// </summary>
            [pbr::OriginalName("NOTIFICATIONS_ONLY")] NotificationsOnly = 2,
            /// <summary>
            ///
            /// Non-notification system buzzer tones only.
            /// Buzzer is enabled only for non-notification tones such as button presses, startup, shutdown, but not for alerts.
            /// </summary>
            [pbr::OriginalName("SYSTEM_ONLY")] SystemOnly = 3,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Position Config
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class PositionConfig : pb::IMessage<PositionConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PositionConfig> _parser = new pb::MessageParser<PositionConfig>(() => new PositionConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PositionConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig(PositionConfig other) : this() {
          positionBroadcastSecs_ = other.positionBroadcastSecs_;
          positionBroadcastSmartEnabled_ = other.positionBroadcastSmartEnabled_;
          fixedPosition_ = other.fixedPosition_;
          gpsEnabled_ = other.gpsEnabled_;
          gpsUpdateInterval_ = other.gpsUpdateInterval_;
          gpsAttemptTime_ = other.gpsAttemptTime_;
          positionFlags_ = other.positionFlags_;
          rxGpio_ = other.rxGpio_;
          txGpio_ = other.txGpio_;
          broadcastSmartMinimumDistance_ = other.broadcastSmartMinimumDistance_;
          broadcastSmartMinimumIntervalSecs_ = other.broadcastSmartMinimumIntervalSecs_;
          gpsEnGpio_ = other.gpsEnGpio_;
          gpsMode_ = other.gpsMode_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PositionConfig Clone() {
          return new PositionConfig(this);
        }

        /// <summary>Field number for the "position_broadcast_secs" field.</summary>
        public const int PositionBroadcastSecsFieldNumber = 1;
        private uint positionBroadcastSecs_;
        /// <summary>
        ///
        /// We should send our position this often (but only if it has changed significantly)
        /// Defaults to 15 minutes
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint PositionBroadcastSecs {
          get { return positionBroadcastSecs_; }
          set {
            positionBroadcastSecs_ = value;
          }
        }

        /// <summary>Field number for the "position_broadcast_smart_enabled" field.</summary>
        public const int PositionBroadcastSmartEnabledFieldNumber = 2;
        private bool positionBroadcastSmartEnabled_;
        /// <summary>
        ///
        /// Adaptive position braoadcast, which is now the default.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool PositionBroadcastSmartEnabled {
          get { return positionBroadcastSmartEnabled_; }
          set {
            positionBroadcastSmartEnabled_ = value;
          }
        }

        /// <summary>Field number for the "fixed_position" field.</summary>
        public const int FixedPositionFieldNumber = 3;
        private bool fixedPosition_;
        /// <summary>
        ///
        /// If set, this node is at a fixed position.
        /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
        /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool FixedPosition {
          get { return fixedPosition_; }
          set {
            fixedPosition_ = value;
          }
        }

        /// <summary>Field number for the "gps_enabled" field.</summary>
        public const int GpsEnabledFieldNumber = 4;
        private bool gpsEnabled_;
        /// <summary>
        ///
        /// Is GPS enabled for this node?
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool GpsEnabled {
          get { return gpsEnabled_; }
          set {
            gpsEnabled_ = value;
          }
        }

        /// <summary>Field number for the "gps_update_interval" field.</summary>
        public const int GpsUpdateIntervalFieldNumber = 5;
        private uint gpsUpdateInterval_;
        /// <summary>
        ///
        /// How often should we try to get GPS position (in seconds)
        /// or zero for the default of once every 30 seconds
        /// or a very large value (maxint) to update only once at boot.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint GpsUpdateInterval {
          get { return gpsUpdateInterval_; }
          set {
            gpsUpdateInterval_ = value;
          }
        }

        /// <summary>Field number for the "gps_attempt_time" field.</summary>
        public const int GpsAttemptTimeFieldNumber = 6;
        private uint gpsAttemptTime_;
        /// <summary>
        ///
        /// Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint GpsAttemptTime {
          get { return gpsAttemptTime_; }
          set {
            gpsAttemptTime_ = value;
          }
        }

        /// <summary>Field number for the "position_flags" field.</summary>
        public const int PositionFlagsFieldNumber = 7;
        private uint positionFlags_;
        /// <summary>
        ///
        /// Bit field of boolean configuration options for POSITION messages
        /// (bitwise OR of PositionFlags)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint PositionFlags {
          get { return positionFlags_; }
          set {
            positionFlags_ = value;
          }
        }

        /// <summary>Field number for the "rx_gpio" field.</summary>
        public const int RxGpioFieldNumber = 8;
        private uint rxGpio_;
        /// <summary>
        ///
        /// (Re)define GPS_RX_PIN for your board.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint RxGpio {
          get { return rxGpio_; }
          set {
            rxGpio_ = value;
          }
        }

        /// <summary>Field number for the "tx_gpio" field.</summary>
        public const int TxGpioFieldNumber = 9;
        private uint txGpio_;
        /// <summary>
        ///
        /// (Re)define GPS_TX_PIN for your board.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint TxGpio {
          get { return txGpio_; }
          set {
            txGpio_ = value;
          }
        }

        /// <summary>Field number for the "broadcast_smart_minimum_distance" field.</summary>
        public const int BroadcastSmartMinimumDistanceFieldNumber = 10;
        private uint broadcastSmartMinimumDistance_;
        /// <summary>
        ///
        /// The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint BroadcastSmartMinimumDistance {
          get { return broadcastSmartMinimumDistance_; }
          set {
            broadcastSmartMinimumDistance_ = value;
          }
        }

        /// <summary>Field number for the "broadcast_smart_minimum_interval_secs" field.</summary>
        public const int BroadcastSmartMinimumIntervalSecsFieldNumber = 11;
        private uint broadcastSmartMinimumIntervalSecs_;
        /// <summary>
        ///
        /// The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint BroadcastSmartMinimumIntervalSecs {
          get { return broadcastSmartMinimumIntervalSecs_; }
          set {
            broadcastSmartMinimumIntervalSecs_ = value;
          }
        }

        /// <summary>Field number for the "gps_en_gpio" field.</summary>
        public const int GpsEnGpioFieldNumber = 12;
        private uint gpsEnGpio_;
        /// <summary>
        ///
        /// (Re)define PIN_GPS_EN for your board.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint GpsEnGpio {
          get { return gpsEnGpio_; }
          set {
            gpsEnGpio_ = value;
          }
        }

        /// <summary>Field number for the "gps_mode" field.</summary>
        public const int GpsModeFieldNumber = 13;
        private global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode gpsMode_ = global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled;
        /// <summary>
        ///
        /// Set where GPS is enabled, disabled, or not present
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode GpsMode {
          get { return gpsMode_; }
          set {
            gpsMode_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PositionConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PositionConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PositionBroadcastSecs != other.PositionBroadcastSecs) return false;
          if (PositionBroadcastSmartEnabled != other.PositionBroadcastSmartEnabled) return false;
          if (FixedPosition != other.FixedPosition) return false;
          if (GpsEnabled != other.GpsEnabled) return false;
          if (GpsUpdateInterval != other.GpsUpdateInterval) return false;
          if (GpsAttemptTime != other.GpsAttemptTime) return false;
          if (PositionFlags != other.PositionFlags) return false;
          if (RxGpio != other.RxGpio) return false;
          if (TxGpio != other.TxGpio) return false;
          if (BroadcastSmartMinimumDistance != other.BroadcastSmartMinimumDistance) return false;
          if (BroadcastSmartMinimumIntervalSecs != other.BroadcastSmartMinimumIntervalSecs) return false;
          if (GpsEnGpio != other.GpsEnGpio) return false;
          if (GpsMode != other.GpsMode) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (PositionBroadcastSecs != 0) hash ^= PositionBroadcastSecs.GetHashCode();
          if (PositionBroadcastSmartEnabled != false) hash ^= PositionBroadcastSmartEnabled.GetHashCode();
          if (FixedPosition != false) hash ^= FixedPosition.GetHashCode();
          if (GpsEnabled != false) hash ^= GpsEnabled.GetHashCode();
          if (GpsUpdateInterval != 0) hash ^= GpsUpdateInterval.GetHashCode();
          if (GpsAttemptTime != 0) hash ^= GpsAttemptTime.GetHashCode();
          if (PositionFlags != 0) hash ^= PositionFlags.GetHashCode();
          if (RxGpio != 0) hash ^= RxGpio.GetHashCode();
          if (TxGpio != 0) hash ^= TxGpio.GetHashCode();
          if (BroadcastSmartMinimumDistance != 0) hash ^= BroadcastSmartMinimumDistance.GetHashCode();
          if (BroadcastSmartMinimumIntervalSecs != 0) hash ^= BroadcastSmartMinimumIntervalSecs.GetHashCode();
          if (GpsEnGpio != 0) hash ^= GpsEnGpio.GetHashCode();
          if (GpsMode != global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled) hash ^= GpsMode.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (PositionBroadcastSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(PositionBroadcastSmartEnabled);
          }
          if (FixedPosition != false) {
            output.WriteRawTag(24);
            output.WriteBool(FixedPosition);
          }
          if (GpsEnabled != false) {
            output.WriteRawTag(32);
            output.WriteBool(GpsEnabled);
          }
          if (GpsUpdateInterval != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(PositionFlags);
          }
          if (RxGpio != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(RxGpio);
          }
          if (TxGpio != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(TxGpio);
          }
          if (BroadcastSmartMinimumDistance != 0) {
            output.WriteRawTag(80);
            output.WriteUInt32(BroadcastSmartMinimumDistance);
          }
          if (BroadcastSmartMinimumIntervalSecs != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(BroadcastSmartMinimumIntervalSecs);
          }
          if (GpsEnGpio != 0) {
            output.WriteRawTag(96);
            output.WriteUInt32(GpsEnGpio);
          }
          if (GpsMode != global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled) {
            output.WriteRawTag(104);
            output.WriteEnum((int) GpsMode);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (PositionBroadcastSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            output.WriteRawTag(16);
            output.WriteBool(PositionBroadcastSmartEnabled);
          }
          if (FixedPosition != false) {
            output.WriteRawTag(24);
            output.WriteBool(FixedPosition);
          }
          if (GpsEnabled != false) {
            output.WriteRawTag(32);
            output.WriteBool(GpsEnabled);
          }
          if (GpsUpdateInterval != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(PositionFlags);
          }
          if (RxGpio != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(RxGpio);
          }
          if (TxGpio != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(TxGpio);
          }
          if (BroadcastSmartMinimumDistance != 0) {
            output.WriteRawTag(80);
            output.WriteUInt32(BroadcastSmartMinimumDistance);
          }
          if (BroadcastSmartMinimumIntervalSecs != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(BroadcastSmartMinimumIntervalSecs);
          }
          if (GpsEnGpio != 0) {
            output.WriteRawTag(96);
            output.WriteUInt32(GpsEnGpio);
          }
          if (GpsMode != global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled) {
            output.WriteRawTag(104);
            output.WriteEnum((int) GpsMode);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (PositionBroadcastSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionBroadcastSecs);
          }
          if (PositionBroadcastSmartEnabled != false) {
            size += 1 + 1;
          }
          if (FixedPosition != false) {
            size += 1 + 1;
          }
          if (GpsEnabled != false) {
            size += 1 + 1;
          }
          if (GpsUpdateInterval != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GpsUpdateInterval);
          }
          if (GpsAttemptTime != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GpsAttemptTime);
          }
          if (PositionFlags != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionFlags);
          }
          if (RxGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RxGpio);
          }
          if (TxGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TxGpio);
          }
          if (BroadcastSmartMinimumDistance != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BroadcastSmartMinimumDistance);
          }
          if (BroadcastSmartMinimumIntervalSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BroadcastSmartMinimumIntervalSecs);
          }
          if (GpsEnGpio != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GpsEnGpio);
          }
          if (GpsMode != global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) GpsMode);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PositionConfig other) {
          if (other == null) {
            return;
          }
          if (other.PositionBroadcastSecs != 0) {
            PositionBroadcastSecs = other.PositionBroadcastSecs;
          }
          if (other.PositionBroadcastSmartEnabled != false) {
            PositionBroadcastSmartEnabled = other.PositionBroadcastSmartEnabled;
          }
          if (other.FixedPosition != false) {
            FixedPosition = other.FixedPosition;
          }
          if (other.GpsEnabled != false) {
            GpsEnabled = other.GpsEnabled;
          }
          if (other.GpsUpdateInterval != 0) {
            GpsUpdateInterval = other.GpsUpdateInterval;
          }
          if (other.GpsAttemptTime != 0) {
            GpsAttemptTime = other.GpsAttemptTime;
          }
          if (other.PositionFlags != 0) {
            PositionFlags = other.PositionFlags;
          }
          if (other.RxGpio != 0) {
            RxGpio = other.RxGpio;
          }
          if (other.TxGpio != 0) {
            TxGpio = other.TxGpio;
          }
          if (other.BroadcastSmartMinimumDistance != 0) {
            BroadcastSmartMinimumDistance = other.BroadcastSmartMinimumDistance;
          }
          if (other.BroadcastSmartMinimumIntervalSecs != 0) {
            BroadcastSmartMinimumIntervalSecs = other.BroadcastSmartMinimumIntervalSecs;
          }
          if (other.GpsEnGpio != 0) {
            GpsEnGpio = other.GpsEnGpio;
          }
          if (other.GpsMode != global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode.Disabled) {
            GpsMode = other.GpsMode;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                PositionBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                PositionBroadcastSmartEnabled = input.ReadBool();
                break;
              }
              case 24: {
                FixedPosition = input.ReadBool();
                break;
              }
              case 32: {
                GpsEnabled = input.ReadBool();
                break;
              }
              case 40: {
                GpsUpdateInterval = input.ReadUInt32();
                break;
              }
              case 48: {
                GpsAttemptTime = input.ReadUInt32();
                break;
              }
              case 56: {
                PositionFlags = input.ReadUInt32();
                break;
              }
              case 64: {
                RxGpio = input.ReadUInt32();
                break;
              }
              case 72: {
                TxGpio = input.ReadUInt32();
                break;
              }
              case 80: {
                BroadcastSmartMinimumDistance = input.ReadUInt32();
                break;
              }
              case 88: {
                BroadcastSmartMinimumIntervalSecs = input.ReadUInt32();
                break;
              }
              case 96: {
                GpsEnGpio = input.ReadUInt32();
                break;
              }
              case 104: {
                GpsMode = (global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                PositionBroadcastSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                PositionBroadcastSmartEnabled = input.ReadBool();
                break;
              }
              case 24: {
                FixedPosition = input.ReadBool();
                break;
              }
              case 32: {
                GpsEnabled = input.ReadBool();
                break;
              }
              case 40: {
                GpsUpdateInterval = input.ReadUInt32();
                break;
              }
              case 48: {
                GpsAttemptTime = input.ReadUInt32();
                break;
              }
              case 56: {
                PositionFlags = input.ReadUInt32();
                break;
              }
              case 64: {
                RxGpio = input.ReadUInt32();
                break;
              }
              case 72: {
                TxGpio = input.ReadUInt32();
                break;
              }
              case 80: {
                BroadcastSmartMinimumDistance = input.ReadUInt32();
                break;
              }
              case 88: {
                BroadcastSmartMinimumIntervalSecs = input.ReadUInt32();
                break;
              }
              case 96: {
                GpsEnGpio = input.ReadUInt32();
                break;
              }
              case 104: {
                GpsMode = (global::Meshtastic.Protobufs.Config.Types.PositionConfig.Types.GpsMode) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the PositionConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// Bit field of boolean configuration options, indicating which optional
          /// fields to include when assembling POSITION messages.
          /// Longitude, latitude, altitude, speed, heading, and DOP
          /// are always included (also time if GPS-synced)
          /// NOTE: the more fields are included, the larger the message will be -
          ///   leading to longer airtime and a higher risk of packet loss
          /// </summary>
          public enum PositionFlags {
            /// <summary>
            ///
            /// Required for compilation
            /// </summary>
            [pbr::OriginalName("UNSET")] Unset = 0,
            /// <summary>
            ///
            /// Include an altitude value (if available)
            /// </summary>
            [pbr::OriginalName("ALTITUDE")] Altitude = 1,
            /// <summary>
            ///
            /// Altitude value is MSL
            /// </summary>
            [pbr::OriginalName("ALTITUDE_MSL")] AltitudeMsl = 2,
            /// <summary>
            ///
            /// Include geoidal separation
            /// </summary>
            [pbr::OriginalName("GEOIDAL_SEPARATION")] GeoidalSeparation = 4,
            /// <summary>
            ///
            /// Include the DOP value ; PDOP used by default, see below
            /// </summary>
            [pbr::OriginalName("DOP")] Dop = 8,
            /// <summary>
            ///
            /// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
            /// </summary>
            [pbr::OriginalName("HVDOP")] Hvdop = 16,
            /// <summary>
            ///
            /// Include number of "satellites in view"
            /// </summary>
            [pbr::OriginalName("SATINVIEW")] Satinview = 32,
            /// <summary>
            ///
            /// Include a sequence number incremented per packet
            /// </summary>
            [pbr::OriginalName("SEQ_NO")] SeqNo = 64,
            /// <summary>
            ///
            /// Include positional timestamp (from GPS solution)
            /// </summary>
            [pbr::OriginalName("TIMESTAMP")] Timestamp = 128,
            /// <summary>
            ///
            /// Include positional heading
            /// Intended for use with vehicle not walking speeds
            /// walking speeds are likely to be error prone like the compass
            /// </summary>
            [pbr::OriginalName("HEADING")] Heading = 256,
            /// <summary>
            ///
            /// Include positional speed
            /// Intended for use with vehicle not walking speeds
            /// walking speeds are likely to be error prone like the compass
            /// </summary>
            [pbr::OriginalName("SPEED")] Speed = 512,
          }

          public enum GpsMode {
            /// <summary>
            ///
            /// GPS is present but disabled
            /// </summary>
            [pbr::OriginalName("DISABLED")] Disabled = 0,
            /// <summary>
            ///
            /// GPS is present and enabled
            /// </summary>
            [pbr::OriginalName("ENABLED")] Enabled = 1,
            /// <summary>
            ///
            /// GPS is not present on the device
            /// </summary>
            [pbr::OriginalName("NOT_PRESENT")] NotPresent = 2,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Power Config\
      /// See [Power Config](/docs/settings/config/power) for additional power config details.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class PowerConfig : pb::IMessage<PowerConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PowerConfig> _parser = new pb::MessageParser<PowerConfig>(() => new PowerConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PowerConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig(PowerConfig other) : this() {
          isPowerSaving_ = other.isPowerSaving_;
          onBatteryShutdownAfterSecs_ = other.onBatteryShutdownAfterSecs_;
          adcMultiplierOverride_ = other.adcMultiplierOverride_;
          waitBluetoothSecs_ = other.waitBluetoothSecs_;
          sdsSecs_ = other.sdsSecs_;
          lsSecs_ = other.lsSecs_;
          minWakeSecs_ = other.minWakeSecs_;
          deviceBatteryInaAddress_ = other.deviceBatteryInaAddress_;
          powermonEnables_ = other.powermonEnables_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PowerConfig Clone() {
          return new PowerConfig(this);
        }

        /// <summary>Field number for the "is_power_saving" field.</summary>
        public const int IsPowerSavingFieldNumber = 1;
        private bool isPowerSaving_;
        /// <summary>
        ///
        /// Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
        /// Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
        /// Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsPowerSaving {
          get { return isPowerSaving_; }
          set {
            isPowerSaving_ = value;
          }
        }

        /// <summary>Field number for the "on_battery_shutdown_after_secs" field.</summary>
        public const int OnBatteryShutdownAfterSecsFieldNumber = 2;
        private uint onBatteryShutdownAfterSecs_;
        /// <summary>
        ///
        ///  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint OnBatteryShutdownAfterSecs {
          get { return onBatteryShutdownAfterSecs_; }
          set {
            onBatteryShutdownAfterSecs_ = value;
          }
        }

        /// <summary>Field number for the "adc_multiplier_override" field.</summary>
        public const int AdcMultiplierOverrideFieldNumber = 3;
        private float adcMultiplierOverride_;
        /// <summary>
        ///
        /// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
        /// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
        /// https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
        /// Should be set to floating point value between 2 and 6
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float AdcMultiplierOverride {
          get { return adcMultiplierOverride_; }
          set {
            adcMultiplierOverride_ = value;
          }
        }

        /// <summary>Field number for the "wait_bluetooth_secs" field.</summary>
        public const int WaitBluetoothSecsFieldNumber = 4;
        private uint waitBluetoothSecs_;
        /// <summary>
        ///
        ///  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
        ///  Technical Details: ESP32 Only 0 for default of 1 minute
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint WaitBluetoothSecs {
          get { return waitBluetoothSecs_; }
          set {
            waitBluetoothSecs_ = value;
          }
        }

        /// <summary>Field number for the "sds_secs" field.</summary>
        public const int SdsSecsFieldNumber = 6;
        private uint sdsSecs_;
        /// <summary>
        ///
        /// Super Deep Sleep Seconds
        /// While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
        /// for this value (default 1 year) or a button press
        /// 0 for default of one year
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint SdsSecs {
          get { return sdsSecs_; }
          set {
            sdsSecs_ = value;
          }
        }

        /// <summary>Field number for the "ls_secs" field.</summary>
        public const int LsSecsFieldNumber = 7;
        private uint lsSecs_;
        /// <summary>
        ///
        /// Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
        /// Technical Details: ESP32 Only 0 for default of 300
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint LsSecs {
          get { return lsSecs_; }
          set {
            lsSecs_ = value;
          }
        }

        /// <summary>Field number for the "min_wake_secs" field.</summary>
        public const int MinWakeSecsFieldNumber = 8;
        private uint minWakeSecs_;
        /// <summary>
        ///
        /// Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
        /// Technical Details: ESP32 Only 0 for default of 10 seconds
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint MinWakeSecs {
          get { return minWakeSecs_; }
          set {
            minWakeSecs_ = value;
          }
        }

        /// <summary>Field number for the "device_battery_ina_address" field.</summary>
        public const int DeviceBatteryInaAddressFieldNumber = 9;
        private uint deviceBatteryInaAddress_;
        /// <summary>
        ///
        /// I2C address of INA_2XX to use for reading device battery voltage
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint DeviceBatteryInaAddress {
          get { return deviceBatteryInaAddress_; }
          set {
            deviceBatteryInaAddress_ = value;
          }
        }

        /// <summary>Field number for the "powermon_enables" field.</summary>
        public const int PowermonEnablesFieldNumber = 32;
        private ulong powermonEnables_;
        /// <summary>
        ///
        /// If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
        /// Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong PowermonEnables {
          get { return powermonEnables_; }
          set {
            powermonEnables_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PowerConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PowerConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (IsPowerSaving != other.IsPowerSaving) return false;
          if (OnBatteryShutdownAfterSecs != other.OnBatteryShutdownAfterSecs) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AdcMultiplierOverride, other.AdcMultiplierOverride)) return false;
          if (WaitBluetoothSecs != other.WaitBluetoothSecs) return false;
          if (SdsSecs != other.SdsSecs) return false;
          if (LsSecs != other.LsSecs) return false;
          if (MinWakeSecs != other.MinWakeSecs) return false;
          if (DeviceBatteryInaAddress != other.DeviceBatteryInaAddress) return false;
          if (PowermonEnables != other.PowermonEnables) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (IsPowerSaving != false) hash ^= IsPowerSaving.GetHashCode();
          if (OnBatteryShutdownAfterSecs != 0) hash ^= OnBatteryShutdownAfterSecs.GetHashCode();
          if (AdcMultiplierOverride != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AdcMultiplierOverride);
          if (WaitBluetoothSecs != 0) hash ^= WaitBluetoothSecs.GetHashCode();
          if (SdsSecs != 0) hash ^= SdsSecs.GetHashCode();
          if (LsSecs != 0) hash ^= LsSecs.GetHashCode();
          if (MinWakeSecs != 0) hash ^= MinWakeSecs.GetHashCode();
          if (DeviceBatteryInaAddress != 0) hash ^= DeviceBatteryInaAddress.GetHashCode();
          if (PowermonEnables != 0UL) hash ^= PowermonEnables.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (IsPowerSaving != false) {
            output.WriteRawTag(8);
            output.WriteBool(IsPowerSaving);
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            output.WriteRawTag(29);
            output.WriteFloat(AdcMultiplierOverride);
          }
          if (WaitBluetoothSecs != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(WaitBluetoothSecs);
          }
          if (SdsSecs != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(SdsSecs);
          }
          if (LsSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(LsSecs);
          }
          if (MinWakeSecs != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(MinWakeSecs);
          }
          if (DeviceBatteryInaAddress != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(DeviceBatteryInaAddress);
          }
          if (PowermonEnables != 0UL) {
            output.WriteRawTag(128, 2);
            output.WriteUInt64(PowermonEnables);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (IsPowerSaving != false) {
            output.WriteRawTag(8);
            output.WriteBool(IsPowerSaving);
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            output.WriteRawTag(29);
            output.WriteFloat(AdcMultiplierOverride);
          }
          if (WaitBluetoothSecs != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(WaitBluetoothSecs);
          }
          if (SdsSecs != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(SdsSecs);
          }
          if (LsSecs != 0) {
            output.WriteRawTag(56);
            output.WriteUInt32(LsSecs);
          }
          if (MinWakeSecs != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(MinWakeSecs);
          }
          if (DeviceBatteryInaAddress != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(DeviceBatteryInaAddress);
          }
          if (PowermonEnables != 0UL) {
            output.WriteRawTag(128, 2);
            output.WriteUInt64(PowermonEnables);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (IsPowerSaving != false) {
            size += 1 + 1;
          }
          if (OnBatteryShutdownAfterSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OnBatteryShutdownAfterSecs);
          }
          if (AdcMultiplierOverride != 0F) {
            size += 1 + 4;
          }
          if (WaitBluetoothSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WaitBluetoothSecs);
          }
          if (SdsSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SdsSecs);
          }
          if (LsSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LsSecs);
          }
          if (MinWakeSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinWakeSecs);
          }
          if (DeviceBatteryInaAddress != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DeviceBatteryInaAddress);
          }
          if (PowermonEnables != 0UL) {
            size += 2 + pb::CodedOutputStream.ComputeUInt64Size(PowermonEnables);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PowerConfig other) {
          if (other == null) {
            return;
          }
          if (other.IsPowerSaving != false) {
            IsPowerSaving = other.IsPowerSaving;
          }
          if (other.OnBatteryShutdownAfterSecs != 0) {
            OnBatteryShutdownAfterSecs = other.OnBatteryShutdownAfterSecs;
          }
          if (other.AdcMultiplierOverride != 0F) {
            AdcMultiplierOverride = other.AdcMultiplierOverride;
          }
          if (other.WaitBluetoothSecs != 0) {
            WaitBluetoothSecs = other.WaitBluetoothSecs;
          }
          if (other.SdsSecs != 0) {
            SdsSecs = other.SdsSecs;
          }
          if (other.LsSecs != 0) {
            LsSecs = other.LsSecs;
          }
          if (other.MinWakeSecs != 0) {
            MinWakeSecs = other.MinWakeSecs;
          }
          if (other.DeviceBatteryInaAddress != 0) {
            DeviceBatteryInaAddress = other.DeviceBatteryInaAddress;
          }
          if (other.PowermonEnables != 0UL) {
            PowermonEnables = other.PowermonEnables;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                IsPowerSaving = input.ReadBool();
                break;
              }
              case 16: {
                OnBatteryShutdownAfterSecs = input.ReadUInt32();
                break;
              }
              case 29: {
                AdcMultiplierOverride = input.ReadFloat();
                break;
              }
              case 32: {
                WaitBluetoothSecs = input.ReadUInt32();
                break;
              }
              case 48: {
                SdsSecs = input.ReadUInt32();
                break;
              }
              case 56: {
                LsSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                MinWakeSecs = input.ReadUInt32();
                break;
              }
              case 72: {
                DeviceBatteryInaAddress = input.ReadUInt32();
                break;
              }
              case 256: {
                PowermonEnables = input.ReadUInt64();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                IsPowerSaving = input.ReadBool();
                break;
              }
              case 16: {
                OnBatteryShutdownAfterSecs = input.ReadUInt32();
                break;
              }
              case 29: {
                AdcMultiplierOverride = input.ReadFloat();
                break;
              }
              case 32: {
                WaitBluetoothSecs = input.ReadUInt32();
                break;
              }
              case 48: {
                SdsSecs = input.ReadUInt32();
                break;
              }
              case 56: {
                LsSecs = input.ReadUInt32();
                break;
              }
              case 64: {
                MinWakeSecs = input.ReadUInt32();
                break;
              }
              case 72: {
                DeviceBatteryInaAddress = input.ReadUInt32();
                break;
              }
              case 256: {
                PowermonEnables = input.ReadUInt64();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// Network Config
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class NetworkConfig : pb::IMessage<NetworkConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<NetworkConfig> _parser = new pb::MessageParser<NetworkConfig>(() => new NetworkConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<NetworkConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig(NetworkConfig other) : this() {
          wifiEnabled_ = other.wifiEnabled_;
          wifiSsid_ = other.wifiSsid_;
          wifiPsk_ = other.wifiPsk_;
          ntpServer_ = other.ntpServer_;
          ethEnabled_ = other.ethEnabled_;
          addressMode_ = other.addressMode_;
          ipv4Config_ = other.ipv4Config_ != null ? other.ipv4Config_.Clone() : null;
          rsyslogServer_ = other.rsyslogServer_;
          enabledProtocols_ = other.enabledProtocols_;
          ipv6Enabled_ = other.ipv6Enabled_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NetworkConfig Clone() {
          return new NetworkConfig(this);
        }

        /// <summary>Field number for the "wifi_enabled" field.</summary>
        public const int WifiEnabledFieldNumber = 1;
        private bool wifiEnabled_;
        /// <summary>
        ///
        /// Enable WiFi (disables Bluetooth)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool WifiEnabled {
          get { return wifiEnabled_; }
          set {
            wifiEnabled_ = value;
          }
        }

        /// <summary>Field number for the "wifi_ssid" field.</summary>
        public const int WifiSsidFieldNumber = 3;
        private string wifiSsid_ = "";
        /// <summary>
        ///
        /// If set, this node will try to join the specified wifi network and
        /// acquire an address via DHCP
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string WifiSsid {
          get { return wifiSsid_; }
          set {
            wifiSsid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "wifi_psk" field.</summary>
        public const int WifiPskFieldNumber = 4;
        private string wifiPsk_ = "";
        /// <summary>
        ///
        /// If set, will be use to authenticate to the named wifi
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string WifiPsk {
          get { return wifiPsk_; }
          set {
            wifiPsk_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "ntp_server" field.</summary>
        public const int NtpServerFieldNumber = 5;
        private string ntpServer_ = "";
        /// <summary>
        ///
        /// NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string NtpServer {
          get { return ntpServer_; }
          set {
            ntpServer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "eth_enabled" field.</summary>
        public const int EthEnabledFieldNumber = 6;
        private bool ethEnabled_;
        /// <summary>
        ///
        /// Enable Ethernet
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool EthEnabled {
          get { return ethEnabled_; }
          set {
            ethEnabled_ = value;
          }
        }

        /// <summary>Field number for the "address_mode" field.</summary>
        public const int AddressModeFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode addressMode_ = global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp;
        /// <summary>
        ///
        /// acquire an address via DHCP or assign static
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode AddressMode {
          get { return addressMode_; }
          set {
            addressMode_ = value;
          }
        }

        /// <summary>Field number for the "ipv4_config" field.</summary>
        public const int Ipv4ConfigFieldNumber = 8;
        private global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config ipv4Config_;
        /// <summary>
        ///
        /// struct to keep static address
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config Ipv4Config {
          get { return ipv4Config_; }
          set {
            ipv4Config_ = value;
          }
        }

        /// <summary>Field number for the "rsyslog_server" field.</summary>
        public const int RsyslogServerFieldNumber = 9;
        private string rsyslogServer_ = "";
        /// <summary>
        ///
        /// rsyslog Server and Port
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string RsyslogServer {
          get { return rsyslogServer_; }
          set {
            rsyslogServer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "enabled_protocols" field.</summary>
        public const int EnabledProtocolsFieldNumber = 10;
        private uint enabledProtocols_;
        /// <summary>
        ///
        /// Flags for enabling/disabling network protocols
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint EnabledProtocols {
          get { return enabledProtocols_; }
          set {
            enabledProtocols_ = value;
          }
        }

        /// <summary>Field number for the "ipv6_enabled" field.</summary>
        public const int Ipv6EnabledFieldNumber = 11;
        private bool ipv6Enabled_;
        /// <summary>
        ///
        /// Enable/Disable ipv6 support
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Ipv6Enabled {
          get { return ipv6Enabled_; }
          set {
            ipv6Enabled_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as NetworkConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(NetworkConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (WifiEnabled != other.WifiEnabled) return false;
          if (WifiSsid != other.WifiSsid) return false;
          if (WifiPsk != other.WifiPsk) return false;
          if (NtpServer != other.NtpServer) return false;
          if (EthEnabled != other.EthEnabled) return false;
          if (AddressMode != other.AddressMode) return false;
          if (!object.Equals(Ipv4Config, other.Ipv4Config)) return false;
          if (RsyslogServer != other.RsyslogServer) return false;
          if (EnabledProtocols != other.EnabledProtocols) return false;
          if (Ipv6Enabled != other.Ipv6Enabled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (WifiEnabled != false) hash ^= WifiEnabled.GetHashCode();
          if (WifiSsid.Length != 0) hash ^= WifiSsid.GetHashCode();
          if (WifiPsk.Length != 0) hash ^= WifiPsk.GetHashCode();
          if (NtpServer.Length != 0) hash ^= NtpServer.GetHashCode();
          if (EthEnabled != false) hash ^= EthEnabled.GetHashCode();
          if (AddressMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp) hash ^= AddressMode.GetHashCode();
          if (ipv4Config_ != null) hash ^= Ipv4Config.GetHashCode();
          if (RsyslogServer.Length != 0) hash ^= RsyslogServer.GetHashCode();
          if (EnabledProtocols != 0) hash ^= EnabledProtocols.GetHashCode();
          if (Ipv6Enabled != false) hash ^= Ipv6Enabled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (WifiEnabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(WifiEnabled);
          }
          if (WifiSsid.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(NtpServer);
          }
          if (EthEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(EthEnabled);
          }
          if (AddressMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp) {
            output.WriteRawTag(56);
            output.WriteEnum((int) AddressMode);
          }
          if (ipv4Config_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(Ipv4Config);
          }
          if (RsyslogServer.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(RsyslogServer);
          }
          if (EnabledProtocols != 0) {
            output.WriteRawTag(80);
            output.WriteUInt32(EnabledProtocols);
          }
          if (Ipv6Enabled != false) {
            output.WriteRawTag(88);
            output.WriteBool(Ipv6Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (WifiEnabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(WifiEnabled);
          }
          if (WifiSsid.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(NtpServer);
          }
          if (EthEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(EthEnabled);
          }
          if (AddressMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp) {
            output.WriteRawTag(56);
            output.WriteEnum((int) AddressMode);
          }
          if (ipv4Config_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(Ipv4Config);
          }
          if (RsyslogServer.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(RsyslogServer);
          }
          if (EnabledProtocols != 0) {
            output.WriteRawTag(80);
            output.WriteUInt32(EnabledProtocols);
          }
          if (Ipv6Enabled != false) {
            output.WriteRawTag(88);
            output.WriteBool(Ipv6Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (WifiEnabled != false) {
            size += 1 + 1;
          }
          if (WifiSsid.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(WifiSsid);
          }
          if (WifiPsk.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(WifiPsk);
          }
          if (NtpServer.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(NtpServer);
          }
          if (EthEnabled != false) {
            size += 1 + 1;
          }
          if (AddressMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AddressMode);
          }
          if (ipv4Config_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ipv4Config);
          }
          if (RsyslogServer.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RsyslogServer);
          }
          if (EnabledProtocols != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EnabledProtocols);
          }
          if (Ipv6Enabled != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(NetworkConfig other) {
          if (other == null) {
            return;
          }
          if (other.WifiEnabled != false) {
            WifiEnabled = other.WifiEnabled;
          }
          if (other.WifiSsid.Length != 0) {
            WifiSsid = other.WifiSsid;
          }
          if (other.WifiPsk.Length != 0) {
            WifiPsk = other.WifiPsk;
          }
          if (other.NtpServer.Length != 0) {
            NtpServer = other.NtpServer;
          }
          if (other.EthEnabled != false) {
            EthEnabled = other.EthEnabled;
          }
          if (other.AddressMode != global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode.Dhcp) {
            AddressMode = other.AddressMode;
          }
          if (other.ipv4Config_ != null) {
            if (ipv4Config_ == null) {
              Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
            }
            Ipv4Config.MergeFrom(other.Ipv4Config);
          }
          if (other.RsyslogServer.Length != 0) {
            RsyslogServer = other.RsyslogServer;
          }
          if (other.EnabledProtocols != 0) {
            EnabledProtocols = other.EnabledProtocols;
          }
          if (other.Ipv6Enabled != false) {
            Ipv6Enabled = other.Ipv6Enabled;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                WifiEnabled = input.ReadBool();
                break;
              }
              case 26: {
                WifiSsid = input.ReadString();
                break;
              }
              case 34: {
                WifiPsk = input.ReadString();
                break;
              }
              case 42: {
                NtpServer = input.ReadString();
                break;
              }
              case 48: {
                EthEnabled = input.ReadBool();
                break;
              }
              case 56: {
                AddressMode = (global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode) input.ReadEnum();
                break;
              }
              case 66: {
                if (ipv4Config_ == null) {
                  Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
                }
                input.ReadMessage(Ipv4Config);
                break;
              }
              case 74: {
                RsyslogServer = input.ReadString();
                break;
              }
              case 80: {
                EnabledProtocols = input.ReadUInt32();
                break;
              }
              case 88: {
                Ipv6Enabled = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                WifiEnabled = input.ReadBool();
                break;
              }
              case 26: {
                WifiSsid = input.ReadString();
                break;
              }
              case 34: {
                WifiPsk = input.ReadString();
                break;
              }
              case 42: {
                NtpServer = input.ReadString();
                break;
              }
              case 48: {
                EthEnabled = input.ReadBool();
                break;
              }
              case 56: {
                AddressMode = (global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.AddressMode) input.ReadEnum();
                break;
              }
              case 66: {
                if (ipv4Config_ == null) {
                  Ipv4Config = new global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Types.IpV4Config();
                }
                input.ReadMessage(Ipv4Config);
                break;
              }
              case 74: {
                RsyslogServer = input.ReadString();
                break;
              }
              case 80: {
                EnabledProtocols = input.ReadUInt32();
                break;
              }
              case 88: {
                Ipv6Enabled = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the NetworkConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum AddressMode {
            /// <summary>
            ///
            /// obtain ip address via DHCP
            /// </summary>
            [pbr::OriginalName("DHCP")] Dhcp = 0,
            /// <summary>
            ///
            /// use static ip address
            /// </summary>
            [pbr::OriginalName("STATIC")] Static = 1,
          }

          /// <summary>
          ///
          /// Available flags auxiliary network protocols
          /// </summary>
          public enum ProtocolFlags {
            /// <summary>
            ///
            /// Do not broadcast packets over any network protocol
            /// </summary>
            [pbr::OriginalName("NO_BROADCAST")] NoBroadcast = 0,
            /// <summary>
            ///
            /// Enable broadcasting packets via UDP over the local network
            /// </summary>
            [pbr::OriginalName("UDP_BROADCAST")] UdpBroadcast = 1,
          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class IpV4Config : pb::IMessage<IpV4Config>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<IpV4Config> _parser = new pb::MessageParser<IpV4Config>(() => new IpV4Config());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<IpV4Config> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Meshtastic.Protobufs.Config.Types.NetworkConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config(IpV4Config other) : this() {
              ip_ = other.ip_;
              gateway_ = other.gateway_;
              subnet_ = other.subnet_;
              dns_ = other.dns_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public IpV4Config Clone() {
              return new IpV4Config(this);
            }

            /// <summary>Field number for the "ip" field.</summary>
            public const int IpFieldNumber = 1;
            private uint ip_;
            /// <summary>
            ///
            /// Static IP address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Ip {
              get { return ip_; }
              set {
                ip_ = value;
              }
            }

            /// <summary>Field number for the "gateway" field.</summary>
            public const int GatewayFieldNumber = 2;
            private uint gateway_;
            /// <summary>
            ///
            /// Static gateway address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Gateway {
              get { return gateway_; }
              set {
                gateway_ = value;
              }
            }

            /// <summary>Field number for the "subnet" field.</summary>
            public const int SubnetFieldNumber = 3;
            private uint subnet_;
            /// <summary>
            ///
            /// Static subnet mask
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Subnet {
              get { return subnet_; }
              set {
                subnet_ = value;
              }
            }

            /// <summary>Field number for the "dns" field.</summary>
            public const int DnsFieldNumber = 4;
            private uint dns_;
            /// <summary>
            ///
            /// Static DNS server address
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint Dns {
              get { return dns_; }
              set {
                dns_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as IpV4Config);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(IpV4Config other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Ip != other.Ip) return false;
              if (Gateway != other.Gateway) return false;
              if (Subnet != other.Subnet) return false;
              if (Dns != other.Dns) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Ip != 0) hash ^= Ip.GetHashCode();
              if (Gateway != 0) hash ^= Gateway.GetHashCode();
              if (Subnet != 0) hash ^= Subnet.GetHashCode();
              if (Dns != 0) hash ^= Dns.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Ip != 0) {
                output.WriteRawTag(13);
                output.WriteFixed32(Ip);
              }
              if (Gateway != 0) {
                output.WriteRawTag(21);
                output.WriteFixed32(Gateway);
              }
              if (Subnet != 0) {
                output.WriteRawTag(29);
                output.WriteFixed32(Subnet);
              }
              if (Dns != 0) {
                output.WriteRawTag(37);
                output.WriteFixed32(Dns);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Ip != 0) {
                output.WriteRawTag(13);
                output.WriteFixed32(Ip);
              }
              if (Gateway != 0) {
                output.WriteRawTag(21);
                output.WriteFixed32(Gateway);
              }
              if (Subnet != 0) {
                output.WriteRawTag(29);
                output.WriteFixed32(Subnet);
              }
              if (Dns != 0) {
                output.WriteRawTag(37);
                output.WriteFixed32(Dns);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Ip != 0) {
                size += 1 + 4;
              }
              if (Gateway != 0) {
                size += 1 + 4;
              }
              if (Subnet != 0) {
                size += 1 + 4;
              }
              if (Dns != 0) {
                size += 1 + 4;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(IpV4Config other) {
              if (other == null) {
                return;
              }
              if (other.Ip != 0) {
                Ip = other.Ip;
              }
              if (other.Gateway != 0) {
                Gateway = other.Gateway;
              }
              if (other.Subnet != 0) {
                Subnet = other.Subnet;
              }
              if (other.Dns != 0) {
                Dns = other.Dns;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 13: {
                    Ip = input.ReadFixed32();
                    break;
                  }
                  case 21: {
                    Gateway = input.ReadFixed32();
                    break;
                  }
                  case 29: {
                    Subnet = input.ReadFixed32();
                    break;
                  }
                  case 37: {
                    Dns = input.ReadFixed32();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 13: {
                    Ip = input.ReadFixed32();
                    break;
                  }
                  case 21: {
                    Gateway = input.ReadFixed32();
                    break;
                  }
                  case 29: {
                    Subnet = input.ReadFixed32();
                    break;
                  }
                  case 37: {
                    Dns = input.ReadFixed32();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Display Config
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class DisplayConfig : pb::IMessage<DisplayConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DisplayConfig> _parser = new pb::MessageParser<DisplayConfig>(() => new DisplayConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DisplayConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig(DisplayConfig other) : this() {
          screenOnSecs_ = other.screenOnSecs_;
          gpsFormat_ = other.gpsFormat_;
          autoScreenCarouselSecs_ = other.autoScreenCarouselSecs_;
          compassNorthTop_ = other.compassNorthTop_;
          flipScreen_ = other.flipScreen_;
          units_ = other.units_;
          oled_ = other.oled_;
          displaymode_ = other.displaymode_;
          headingBold_ = other.headingBold_;
          wakeOnTapOrMotion_ = other.wakeOnTapOrMotion_;
          compassOrientation_ = other.compassOrientation_;
          use12HClock_ = other.use12HClock_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayConfig Clone() {
          return new DisplayConfig(this);
        }

        /// <summary>Field number for the "screen_on_secs" field.</summary>
        public const int ScreenOnSecsFieldNumber = 1;
        private uint screenOnSecs_;
        /// <summary>
        ///
        /// Number of seconds the screen stays on after pressing the user button or receiving a message
        /// 0 for default of one minute MAXUINT for always on
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ScreenOnSecs {
          get { return screenOnSecs_; }
          set {
            screenOnSecs_ = value;
          }
        }

        /// <summary>Field number for the "gps_format" field.</summary>
        public const int GpsFormatFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat gpsFormat_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec;
        /// <summary>
        ///
        /// How the GPS coordinates are formatted on the OLED screen.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat GpsFormat {
          get { return gpsFormat_; }
          set {
            gpsFormat_ = value;
          }
        }

        /// <summary>Field number for the "auto_screen_carousel_secs" field.</summary>
        public const int AutoScreenCarouselSecsFieldNumber = 3;
        private uint autoScreenCarouselSecs_;
        /// <summary>
        ///
        /// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
        /// Potentially useful for devices without user buttons.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint AutoScreenCarouselSecs {
          get { return autoScreenCarouselSecs_; }
          set {
            autoScreenCarouselSecs_ = value;
          }
        }

        /// <summary>Field number for the "compass_north_top" field.</summary>
        public const int CompassNorthTopFieldNumber = 4;
        private bool compassNorthTop_;
        /// <summary>
        ///
        /// If this is set, the displayed compass will always point north. if unset, the old behaviour
        /// (top of display is heading direction) is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CompassNorthTop {
          get { return compassNorthTop_; }
          set {
            compassNorthTop_ = value;
          }
        }

        /// <summary>Field number for the "flip_screen" field.</summary>
        public const int FlipScreenFieldNumber = 5;
        private bool flipScreen_;
        /// <summary>
        ///
        /// Flip screen vertically, for cases that mount the screen upside down
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool FlipScreen {
          get { return flipScreen_; }
          set {
            flipScreen_ = value;
          }
        }

        /// <summary>Field number for the "units" field.</summary>
        public const int UnitsFieldNumber = 6;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits units_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric;
        /// <summary>
        ///
        /// Perferred display units
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits Units {
          get { return units_; }
          set {
            units_ = value;
          }
        }

        /// <summary>Field number for the "oled" field.</summary>
        public const int OledFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType oled_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto;
        /// <summary>
        ///
        /// Override auto-detect in screen
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType Oled {
          get { return oled_; }
          set {
            oled_ = value;
          }
        }

        /// <summary>Field number for the "displaymode" field.</summary>
        public const int DisplaymodeFieldNumber = 8;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode displaymode_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default;
        /// <summary>
        ///
        /// Display Mode
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode Displaymode {
          get { return displaymode_; }
          set {
            displaymode_ = value;
          }
        }

        /// <summary>Field number for the "heading_bold" field.</summary>
        public const int HeadingBoldFieldNumber = 9;
        private bool headingBold_;
        /// <summary>
        ///
        /// Print first line in pseudo-bold? FALSE is original style, TRUE is bold
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HeadingBold {
          get { return headingBold_; }
          set {
            headingBold_ = value;
          }
        }

        /// <summary>Field number for the "wake_on_tap_or_motion" field.</summary>
        public const int WakeOnTapOrMotionFieldNumber = 10;
        private bool wakeOnTapOrMotion_;
        /// <summary>
        ///
        /// Should we wake the screen up on accelerometer detected motion or tap
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool WakeOnTapOrMotion {
          get { return wakeOnTapOrMotion_; }
          set {
            wakeOnTapOrMotion_ = value;
          }
        }

        /// <summary>Field number for the "compass_orientation" field.</summary>
        public const int CompassOrientationFieldNumber = 11;
        private global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation compassOrientation_ = global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0;
        /// <summary>
        ///
        /// Indicates how to rotate or invert the compass output to accurate display on the display.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation CompassOrientation {
          get { return compassOrientation_; }
          set {
            compassOrientation_ = value;
          }
        }

        /// <summary>Field number for the "use_12h_clock" field.</summary>
        public const int Use12HClockFieldNumber = 12;
        private bool use12HClock_;
        /// <summary>
        ///
        /// If false (default), the device will display the time in 24-hour format on screen.
        /// If true, the device will display the time in 12-hour format on screen.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Use12HClock {
          get { return use12HClock_; }
          set {
            use12HClock_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DisplayConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DisplayConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ScreenOnSecs != other.ScreenOnSecs) return false;
          if (GpsFormat != other.GpsFormat) return false;
          if (AutoScreenCarouselSecs != other.AutoScreenCarouselSecs) return false;
          if (CompassNorthTop != other.CompassNorthTop) return false;
          if (FlipScreen != other.FlipScreen) return false;
          if (Units != other.Units) return false;
          if (Oled != other.Oled) return false;
          if (Displaymode != other.Displaymode) return false;
          if (HeadingBold != other.HeadingBold) return false;
          if (WakeOnTapOrMotion != other.WakeOnTapOrMotion) return false;
          if (CompassOrientation != other.CompassOrientation) return false;
          if (Use12HClock != other.Use12HClock) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (ScreenOnSecs != 0) hash ^= ScreenOnSecs.GetHashCode();
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) hash ^= GpsFormat.GetHashCode();
          if (AutoScreenCarouselSecs != 0) hash ^= AutoScreenCarouselSecs.GetHashCode();
          if (CompassNorthTop != false) hash ^= CompassNorthTop.GetHashCode();
          if (FlipScreen != false) hash ^= FlipScreen.GetHashCode();
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) hash ^= Units.GetHashCode();
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) hash ^= Oled.GetHashCode();
          if (Displaymode != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default) hash ^= Displaymode.GetHashCode();
          if (HeadingBold != false) hash ^= HeadingBold.GetHashCode();
          if (WakeOnTapOrMotion != false) hash ^= WakeOnTapOrMotion.GetHashCode();
          if (CompassOrientation != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0) hash ^= CompassOrientation.GetHashCode();
          if (Use12HClock != false) hash ^= Use12HClock.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ScreenOnSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            output.WriteRawTag(16);
            output.WriteEnum((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            output.WriteRawTag(32);
            output.WriteBool(CompassNorthTop);
          }
          if (FlipScreen != false) {
            output.WriteRawTag(40);
            output.WriteBool(FlipScreen);
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            output.WriteRawTag(48);
            output.WriteEnum((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Oled);
          }
          if (Displaymode != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default) {
            output.WriteRawTag(64);
            output.WriteEnum((int) Displaymode);
          }
          if (HeadingBold != false) {
            output.WriteRawTag(72);
            output.WriteBool(HeadingBold);
          }
          if (WakeOnTapOrMotion != false) {
            output.WriteRawTag(80);
            output.WriteBool(WakeOnTapOrMotion);
          }
          if (CompassOrientation != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0) {
            output.WriteRawTag(88);
            output.WriteEnum((int) CompassOrientation);
          }
          if (Use12HClock != false) {
            output.WriteRawTag(96);
            output.WriteBool(Use12HClock);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ScreenOnSecs != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            output.WriteRawTag(16);
            output.WriteEnum((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            output.WriteRawTag(32);
            output.WriteBool(CompassNorthTop);
          }
          if (FlipScreen != false) {
            output.WriteRawTag(40);
            output.WriteBool(FlipScreen);
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            output.WriteRawTag(48);
            output.WriteEnum((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Oled);
          }
          if (Displaymode != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default) {
            output.WriteRawTag(64);
            output.WriteEnum((int) Displaymode);
          }
          if (HeadingBold != false) {
            output.WriteRawTag(72);
            output.WriteBool(HeadingBold);
          }
          if (WakeOnTapOrMotion != false) {
            output.WriteRawTag(80);
            output.WriteBool(WakeOnTapOrMotion);
          }
          if (CompassOrientation != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0) {
            output.WriteRawTag(88);
            output.WriteEnum((int) CompassOrientation);
          }
          if (Use12HClock != false) {
            output.WriteRawTag(96);
            output.WriteBool(Use12HClock);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (ScreenOnSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ScreenOnSecs);
          }
          if (GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) GpsFormat);
          }
          if (AutoScreenCarouselSecs != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AutoScreenCarouselSecs);
          }
          if (CompassNorthTop != false) {
            size += 1 + 1;
          }
          if (FlipScreen != false) {
            size += 1 + 1;
          }
          if (Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Units);
          }
          if (Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Oled);
          }
          if (Displaymode != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Displaymode);
          }
          if (HeadingBold != false) {
            size += 1 + 1;
          }
          if (WakeOnTapOrMotion != false) {
            size += 1 + 1;
          }
          if (CompassOrientation != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CompassOrientation);
          }
          if (Use12HClock != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DisplayConfig other) {
          if (other == null) {
            return;
          }
          if (other.ScreenOnSecs != 0) {
            ScreenOnSecs = other.ScreenOnSecs;
          }
          if (other.GpsFormat != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat.Dec) {
            GpsFormat = other.GpsFormat;
          }
          if (other.AutoScreenCarouselSecs != 0) {
            AutoScreenCarouselSecs = other.AutoScreenCarouselSecs;
          }
          if (other.CompassNorthTop != false) {
            CompassNorthTop = other.CompassNorthTop;
          }
          if (other.FlipScreen != false) {
            FlipScreen = other.FlipScreen;
          }
          if (other.Units != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits.Metric) {
            Units = other.Units;
          }
          if (other.Oled != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType.OledAuto) {
            Oled = other.Oled;
          }
          if (other.Displaymode != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode.Default) {
            Displaymode = other.Displaymode;
          }
          if (other.HeadingBold != false) {
            HeadingBold = other.HeadingBold;
          }
          if (other.WakeOnTapOrMotion != false) {
            WakeOnTapOrMotion = other.WakeOnTapOrMotion;
          }
          if (other.CompassOrientation != global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation.Degrees0) {
            CompassOrientation = other.CompassOrientation;
          }
          if (other.Use12HClock != false) {
            Use12HClock = other.Use12HClock;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ScreenOnSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                GpsFormat = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat) input.ReadEnum();
                break;
              }
              case 24: {
                AutoScreenCarouselSecs = input.ReadUInt32();
                break;
              }
              case 32: {
                CompassNorthTop = input.ReadBool();
                break;
              }
              case 40: {
                FlipScreen = input.ReadBool();
                break;
              }
              case 48: {
                Units = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits) input.ReadEnum();
                break;
              }
              case 56: {
                Oled = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType) input.ReadEnum();
                break;
              }
              case 64: {
                Displaymode = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode) input.ReadEnum();
                break;
              }
              case 72: {
                HeadingBold = input.ReadBool();
                break;
              }
              case 80: {
                WakeOnTapOrMotion = input.ReadBool();
                break;
              }
              case 88: {
                CompassOrientation = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation) input.ReadEnum();
                break;
              }
              case 96: {
                Use12HClock = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ScreenOnSecs = input.ReadUInt32();
                break;
              }
              case 16: {
                GpsFormat = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.GpsCoordinateFormat) input.ReadEnum();
                break;
              }
              case 24: {
                AutoScreenCarouselSecs = input.ReadUInt32();
                break;
              }
              case 32: {
                CompassNorthTop = input.ReadBool();
                break;
              }
              case 40: {
                FlipScreen = input.ReadBool();
                break;
              }
              case 48: {
                Units = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayUnits) input.ReadEnum();
                break;
              }
              case 56: {
                Oled = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.OledType) input.ReadEnum();
                break;
              }
              case 64: {
                Displaymode = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.DisplayMode) input.ReadEnum();
                break;
              }
              case 72: {
                HeadingBold = input.ReadBool();
                break;
              }
              case 80: {
                WakeOnTapOrMotion = input.ReadBool();
                break;
              }
              case 88: {
                CompassOrientation = (global::Meshtastic.Protobufs.Config.Types.DisplayConfig.Types.CompassOrientation) input.ReadEnum();
                break;
              }
              case 96: {
                Use12HClock = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the DisplayConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///
          /// How the GPS coordinates are displayed on the OLED screen.
          /// </summary>
          public enum GpsCoordinateFormat {
            /// <summary>
            ///
            /// GPS coordinates are displayed in the normal decimal degrees format:
            /// DD.DDDDDD DDD.DDDDDD
            /// </summary>
            [pbr::OriginalName("DEC")] Dec = 0,
            /// <summary>
            ///
            /// GPS coordinates are displayed in the degrees minutes seconds format:
            /// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
            /// </summary>
            [pbr::OriginalName("DMS")] Dms = 1,
            /// <summary>
            ///
            /// Universal Transverse Mercator format:
            /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
            /// </summary>
            [pbr::OriginalName("UTM")] Utm = 2,
            /// <summary>
            ///
            /// Military Grid Reference System format:
            /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
            /// E is easting, N is northing
            /// </summary>
            [pbr::OriginalName("MGRS")] Mgrs = 3,
            /// <summary>
            ///
            /// Open Location Code (aka Plus Codes).
            /// </summary>
            [pbr::OriginalName("OLC")] Olc = 4,
            /// <summary>
            ///
            /// Ordnance Survey Grid Reference (the National Grid System of the UK).
            /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
            /// E is the easting, N is the northing
            /// </summary>
            [pbr::OriginalName("OSGR")] Osgr = 5,
          }

          /// <summary>
          ///
          /// Unit display preference
          /// </summary>
          public enum DisplayUnits {
            /// <summary>
            ///
            /// Metric (Default)
            /// </summary>
            [pbr::OriginalName("METRIC")] Metric = 0,
            /// <summary>
            ///
            /// Imperial
            /// </summary>
            [pbr::OriginalName("IMPERIAL")] Imperial = 1,
          }

          /// <summary>
          ///
          /// Override OLED outo detect with this if it fails.
          /// </summary>
          public enum OledType {
            /// <summary>
            ///
            /// Default / Autodetect
            /// </summary>
            [pbr::OriginalName("OLED_AUTO")] OledAuto = 0,
            /// <summary>
            ///
            /// Default / Autodetect
            /// </summary>
            [pbr::OriginalName("OLED_SSD1306")] OledSsd1306 = 1,
            /// <summary>
            ///
            /// Default / Autodetect
            /// </summary>
            [pbr::OriginalName("OLED_SH1106")] OledSh1106 = 2,
            /// <summary>
            ///
            /// Can not be auto detected but set by proto. Used for 128x128 screens
            /// </summary>
            [pbr::OriginalName("OLED_SH1107")] OledSh1107 = 3,
            /// <summary>
            ///
            /// Can not be auto detected but set by proto. Used for 128x64 screens
            /// </summary>
            [pbr::OriginalName("OLED_SH1107_128_64")] OledSh110712864 = 4,
          }

          public enum DisplayMode {
            /// <summary>
            ///
            /// Default. The old style for the 128x64 OLED screen
            /// </summary>
            [pbr::OriginalName("DEFAULT")] Default = 0,
            /// <summary>
            ///
            /// Rearrange display elements to cater for bicolor OLED displays
            /// </summary>
            [pbr::OriginalName("TWOCOLOR")] Twocolor = 1,
            /// <summary>
            ///
            /// Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
            /// </summary>
            [pbr::OriginalName("INVERTED")] Inverted = 2,
            /// <summary>
            ///
            /// TFT Full Color Displays (not implemented yet)
            /// </summary>
            [pbr::OriginalName("COLOR")] Color = 3,
          }

          public enum CompassOrientation {
            /// <summary>
            ///
            /// The compass and the display are in the same orientation.
            /// </summary>
            [pbr::OriginalName("DEGREES_0")] Degrees0 = 0,
            /// <summary>
            ///
            /// Rotate the compass by 90 degrees.
            /// </summary>
            [pbr::OriginalName("DEGREES_90")] Degrees90 = 1,
            /// <summary>
            ///
            /// Rotate the compass by 180 degrees.
            /// </summary>
            [pbr::OriginalName("DEGREES_180")] Degrees180 = 2,
            /// <summary>
            ///
            /// Rotate the compass by 270 degrees.
            /// </summary>
            [pbr::OriginalName("DEGREES_270")] Degrees270 = 3,
            /// <summary>
            ///
            /// Don't rotate the compass, but invert the result.
            /// </summary>
            [pbr::OriginalName("DEGREES_0_INVERTED")] Degrees0Inverted = 4,
            /// <summary>
            ///
            /// Rotate the compass by 90 degrees and invert.
            /// </summary>
            [pbr::OriginalName("DEGREES_90_INVERTED")] Degrees90Inverted = 5,
            /// <summary>
            ///
            /// Rotate the compass by 180 degrees and invert.
            /// </summary>
            [pbr::OriginalName("DEGREES_180_INVERTED")] Degrees180Inverted = 6,
            /// <summary>
            ///
            /// Rotate the compass by 270 degrees and invert.
            /// </summary>
            [pbr::OriginalName("DEGREES_270_INVERTED")] Degrees270Inverted = 7,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// Lora Config
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LoRaConfig : pb::IMessage<LoRaConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LoRaConfig> _parser = new pb::MessageParser<LoRaConfig>(() => new LoRaConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LoRaConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig(LoRaConfig other) : this() {
          usePreset_ = other.usePreset_;
          modemPreset_ = other.modemPreset_;
          bandwidth_ = other.bandwidth_;
          spreadFactor_ = other.spreadFactor_;
          codingRate_ = other.codingRate_;
          frequencyOffset_ = other.frequencyOffset_;
          region_ = other.region_;
          hopLimit_ = other.hopLimit_;
          txEnabled_ = other.txEnabled_;
          txPower_ = other.txPower_;
          channelNum_ = other.channelNum_;
          overrideDutyCycle_ = other.overrideDutyCycle_;
          sx126XRxBoostedGain_ = other.sx126XRxBoostedGain_;
          overrideFrequency_ = other.overrideFrequency_;
          paFanDisabled_ = other.paFanDisabled_;
          ignoreIncoming_ = other.ignoreIncoming_.Clone();
          ignoreMqtt_ = other.ignoreMqtt_;
          configOkToMqtt_ = other.configOkToMqtt_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoRaConfig Clone() {
          return new LoRaConfig(this);
        }

        /// <summary>Field number for the "use_preset" field.</summary>
        public const int UsePresetFieldNumber = 1;
        private bool usePreset_;
        /// <summary>
        ///
        /// When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
        /// will be taked from their respective manually defined fields
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UsePreset {
          get { return usePreset_; }
          set {
            usePreset_ = value;
          }
        }

        /// <summary>Field number for the "modem_preset" field.</summary>
        public const int ModemPresetFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset modemPreset_ = global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast;
        /// <summary>
        ///
        /// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
        /// As a heuristic: If bandwidth is specified, do not use modem_config.
        /// Because protobufs take ZERO space when the value is zero this works out nicely.
        /// This value is replaced by bandwidth/spread_factor/coding_rate.
        /// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset ModemPreset {
          get { return modemPreset_; }
          set {
            modemPreset_ = value;
          }
        }

        /// <summary>Field number for the "bandwidth" field.</summary>
        public const int BandwidthFieldNumber = 3;
        private uint bandwidth_;
        /// <summary>
        ///
        /// Bandwidth in MHz
        /// Certain bandwidth numbers are 'special' and will be converted to the
        /// appropriate floating point value: 31 -> 31.25MHz
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint Bandwidth {
          get { return bandwidth_; }
          set {
            bandwidth_ = value;
          }
        }

        /// <summary>Field number for the "spread_factor" field.</summary>
        public const int SpreadFactorFieldNumber = 4;
        private uint spreadFactor_;
        /// <summary>
        ///
        /// A number from 7 to 12.
        /// Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint SpreadFactor {
          get { return spreadFactor_; }
          set {
            spreadFactor_ = value;
          }
        }

        /// <summary>Field number for the "coding_rate" field.</summary>
        public const int CodingRateFieldNumber = 5;
        private uint codingRate_;
        /// <summary>
        ///
        /// The denominator of the coding rate.
        /// ie for 4/5, the value is 5. 4/8 the value is 8.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint CodingRate {
          get { return codingRate_; }
          set {
            codingRate_ = value;
          }
        }

        /// <summary>Field number for the "frequency_offset" field.</summary>
        public const int FrequencyOffsetFieldNumber = 6;
        private float frequencyOffset_;
        /// <summary>
        ///
        /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
        /// A frequency offset that is added to to the calculated band center frequency.
        /// Used to correct for crystal calibration errors.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FrequencyOffset {
          get { return frequencyOffset_; }
          set {
            frequencyOffset_ = value;
          }
        }

        /// <summary>Field number for the "region" field.</summary>
        public const int RegionFieldNumber = 7;
        private global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode region_ = global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset;
        /// <summary>
        ///
        /// The region code for the radio (US, CN, EU433, etc...)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode Region {
          get { return region_; }
          set {
            region_ = value;
          }
        }

        /// <summary>Field number for the "hop_limit" field.</summary>
        public const int HopLimitFieldNumber = 8;
        private uint hopLimit_;
        /// <summary>
        ///
        /// Maximum number of hops. This can't be greater than 7.
        /// Default of 3
        /// Attempting to set a value > 7 results in the default
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint HopLimit {
          get { return hopLimit_; }
          set {
            hopLimit_ = value;
          }
        }

        /// <summary>Field number for the "tx_enabled" field.</summary>
        public const int TxEnabledFieldNumber = 9;
        private bool txEnabled_;
        /// <summary>
        ///
        /// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
        /// Defaults to false
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool TxEnabled {
          get { return txEnabled_; }
          set {
            txEnabled_ = value;
          }
        }

        /// <summary>Field number for the "tx_power" field.</summary>
        public const int TxPowerFieldNumber = 10;
        private int txPower_;
        /// <summary>
        ///
        /// If zero, then use default max legal continuous power (ie. something that won't
        /// burn out the radio hardware)
        /// In most cases you should use zero here.
        /// Units are in dBm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int TxPower {
          get { return txPower_; }
          set {
            txPower_ = value;
          }
        }

        /// <summary>Field number for the "channel_num" field.</summary>
        public const int ChannelNumFieldNumber = 11;
        private uint channelNum_;
        /// <summary>
        ///
        /// This controls the actual hardware frequency the radio transmits on.
        /// Most users should never need to be exposed to this field/concept.
        /// A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
        /// If ZERO then the rule is "use the old channel name hash based
        /// algorithm to derive the channel number")
        /// If using the hash algorithm the channel number will be: hash(channel_name) %
        /// NUM_CHANNELS (Where num channels depends on the regulatory region).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint ChannelNum {
          get { return channelNum_; }
          set {
            channelNum_ = value;
          }
        }

        /// <summary>Field number for the "override_duty_cycle" field.</summary>
        public const int OverrideDutyCycleFieldNumber = 12;
        private bool overrideDutyCycle_;
        /// <summary>
        ///
        /// If true, duty cycle limits will be exceeded and thus you're possibly not following
        /// the local regulations if you're not a HAM.
        /// Has no effect if the duty cycle of the used region is 100%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool OverrideDutyCycle {
          get { return overrideDutyCycle_; }
          set {
            overrideDutyCycle_ = value;
          }
        }

        /// <summary>Field number for the "sx126x_rx_boosted_gain" field.</summary>
        public const int Sx126XRxBoostedGainFieldNumber = 13;
        private bool sx126XRxBoostedGain_;
        /// <summary>
        ///
        /// If true, sets RX boosted gain mode on SX126X based radios
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Sx126XRxBoostedGain {
          get { return sx126XRxBoostedGain_; }
          set {
            sx126XRxBoostedGain_ = value;
          }
        }

        /// <summary>Field number for the "override_frequency" field.</summary>
        public const int OverrideFrequencyFieldNumber = 14;
        private float overrideFrequency_;
        /// <summary>
        ///
        /// This parameter is for advanced users and licensed HAM radio operators.
        /// Ignore Channel Calculation and use this frequency instead. The frequency_offset
        /// will still be applied. This will allow you to use out-of-band frequencies.
        /// Please respect your local laws and regulations. If you are a HAM, make sure you
        /// enable HAM mode and turn off encryption.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float OverrideFrequency {
          get { return overrideFrequency_; }
          set {
            overrideFrequency_ = value;
          }
        }

        /// <summary>Field number for the "pa_fan_disabled" field.</summary>
        public const int PaFanDisabledFieldNumber = 15;
        private bool paFanDisabled_;
        /// <summary>
        ///
        /// If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool PaFanDisabled {
          get { return paFanDisabled_; }
          set {
            paFanDisabled_ = value;
          }
        }

        /// <summary>Field number for the "ignore_incoming" field.</summary>
        public const int IgnoreIncomingFieldNumber = 103;
        private static readonly pb::FieldCodec<uint> _repeated_ignoreIncoming_codec
            = pb::FieldCodec.ForUInt32(826);
        private readonly pbc::RepeatedField<uint> ignoreIncoming_ = new pbc::RepeatedField<uint>();
        /// <summary>
        ///
        /// For testing it is useful sometimes to force a node to never listen to
        /// particular other nodes (simulating radio out of range). All nodenums listed
        /// in ignore_incoming will have packets they send dropped on receive (by router.cpp)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<uint> IgnoreIncoming {
          get { return ignoreIncoming_; }
        }

        /// <summary>Field number for the "ignore_mqtt" field.</summary>
        public const int IgnoreMqttFieldNumber = 104;
        private bool ignoreMqtt_;
        /// <summary>
        ///
        /// If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IgnoreMqtt {
          get { return ignoreMqtt_; }
          set {
            ignoreMqtt_ = value;
          }
        }

        /// <summary>Field number for the "config_ok_to_mqtt" field.</summary>
        public const int ConfigOkToMqttFieldNumber = 105;
        private bool configOkToMqtt_;
        /// <summary>
        ///
        /// Sets the ok_to_mqtt bit on outgoing packets
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ConfigOkToMqtt {
          get { return configOkToMqtt_; }
          set {
            configOkToMqtt_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LoRaConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LoRaConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UsePreset != other.UsePreset) return false;
          if (ModemPreset != other.ModemPreset) return false;
          if (Bandwidth != other.Bandwidth) return false;
          if (SpreadFactor != other.SpreadFactor) return false;
          if (CodingRate != other.CodingRate) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FrequencyOffset, other.FrequencyOffset)) return false;
          if (Region != other.Region) return false;
          if (HopLimit != other.HopLimit) return false;
          if (TxEnabled != other.TxEnabled) return false;
          if (TxPower != other.TxPower) return false;
          if (ChannelNum != other.ChannelNum) return false;
          if (OverrideDutyCycle != other.OverrideDutyCycle) return false;
          if (Sx126XRxBoostedGain != other.Sx126XRxBoostedGain) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverrideFrequency, other.OverrideFrequency)) return false;
          if (PaFanDisabled != other.PaFanDisabled) return false;
          if(!ignoreIncoming_.Equals(other.ignoreIncoming_)) return false;
          if (IgnoreMqtt != other.IgnoreMqtt) return false;
          if (ConfigOkToMqtt != other.ConfigOkToMqtt) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UsePreset != false) hash ^= UsePreset.GetHashCode();
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) hash ^= ModemPreset.GetHashCode();
          if (Bandwidth != 0) hash ^= Bandwidth.GetHashCode();
          if (SpreadFactor != 0) hash ^= SpreadFactor.GetHashCode();
          if (CodingRate != 0) hash ^= CodingRate.GetHashCode();
          if (FrequencyOffset != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FrequencyOffset);
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) hash ^= Region.GetHashCode();
          if (HopLimit != 0) hash ^= HopLimit.GetHashCode();
          if (TxEnabled != false) hash ^= TxEnabled.GetHashCode();
          if (TxPower != 0) hash ^= TxPower.GetHashCode();
          if (ChannelNum != 0) hash ^= ChannelNum.GetHashCode();
          if (OverrideDutyCycle != false) hash ^= OverrideDutyCycle.GetHashCode();
          if (Sx126XRxBoostedGain != false) hash ^= Sx126XRxBoostedGain.GetHashCode();
          if (OverrideFrequency != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverrideFrequency);
          if (PaFanDisabled != false) hash ^= PaFanDisabled.GetHashCode();
          hash ^= ignoreIncoming_.GetHashCode();
          if (IgnoreMqtt != false) hash ^= IgnoreMqtt.GetHashCode();
          if (ConfigOkToMqtt != false) hash ^= ConfigOkToMqtt.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UsePreset != false) {
            output.WriteRawTag(8);
            output.WriteBool(UsePreset);
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Bandwidth);
          }
          if (SpreadFactor != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(SpreadFactor);
          }
          if (CodingRate != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            output.WriteRawTag(53);
            output.WriteFloat(FrequencyOffset);
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Region);
          }
          if (HopLimit != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(HopLimit);
          }
          if (TxEnabled != false) {
            output.WriteRawTag(72);
            output.WriteBool(TxEnabled);
          }
          if (TxPower != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(TxPower);
          }
          if (ChannelNum != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            output.WriteRawTag(96);
            output.WriteBool(OverrideDutyCycle);
          }
          if (Sx126XRxBoostedGain != false) {
            output.WriteRawTag(104);
            output.WriteBool(Sx126XRxBoostedGain);
          }
          if (OverrideFrequency != 0F) {
            output.WriteRawTag(117);
            output.WriteFloat(OverrideFrequency);
          }
          if (PaFanDisabled != false) {
            output.WriteRawTag(120);
            output.WriteBool(PaFanDisabled);
          }
          ignoreIncoming_.WriteTo(output, _repeated_ignoreIncoming_codec);
          if (IgnoreMqtt != false) {
            output.WriteRawTag(192, 6);
            output.WriteBool(IgnoreMqtt);
          }
          if (ConfigOkToMqtt != false) {
            output.WriteRawTag(200, 6);
            output.WriteBool(ConfigOkToMqtt);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UsePreset != false) {
            output.WriteRawTag(8);
            output.WriteBool(UsePreset);
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Bandwidth);
          }
          if (SpreadFactor != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(SpreadFactor);
          }
          if (CodingRate != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            output.WriteRawTag(53);
            output.WriteFloat(FrequencyOffset);
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Region);
          }
          if (HopLimit != 0) {
            output.WriteRawTag(64);
            output.WriteUInt32(HopLimit);
          }
          if (TxEnabled != false) {
            output.WriteRawTag(72);
            output.WriteBool(TxEnabled);
          }
          if (TxPower != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(TxPower);
          }
          if (ChannelNum != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            output.WriteRawTag(96);
            output.WriteBool(OverrideDutyCycle);
          }
          if (Sx126XRxBoostedGain != false) {
            output.WriteRawTag(104);
            output.WriteBool(Sx126XRxBoostedGain);
          }
          if (OverrideFrequency != 0F) {
            output.WriteRawTag(117);
            output.WriteFloat(OverrideFrequency);
          }
          if (PaFanDisabled != false) {
            output.WriteRawTag(120);
            output.WriteBool(PaFanDisabled);
          }
          ignoreIncoming_.WriteTo(ref output, _repeated_ignoreIncoming_codec);
          if (IgnoreMqtt != false) {
            output.WriteRawTag(192, 6);
            output.WriteBool(IgnoreMqtt);
          }
          if (ConfigOkToMqtt != false) {
            output.WriteRawTag(200, 6);
            output.WriteBool(ConfigOkToMqtt);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UsePreset != false) {
            size += 1 + 1;
          }
          if (ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ModemPreset);
          }
          if (Bandwidth != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bandwidth);
          }
          if (SpreadFactor != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpreadFactor);
          }
          if (CodingRate != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CodingRate);
          }
          if (FrequencyOffset != 0F) {
            size += 1 + 4;
          }
          if (Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Region);
          }
          if (HopLimit != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HopLimit);
          }
          if (TxEnabled != false) {
            size += 1 + 1;
          }
          if (TxPower != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(TxPower);
          }
          if (ChannelNum != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ChannelNum);
          }
          if (OverrideDutyCycle != false) {
            size += 1 + 1;
          }
          if (Sx126XRxBoostedGain != false) {
            size += 1 + 1;
          }
          if (OverrideFrequency != 0F) {
            size += 1 + 4;
          }
          if (PaFanDisabled != false) {
            size += 1 + 1;
          }
          size += ignoreIncoming_.CalculateSize(_repeated_ignoreIncoming_codec);
          if (IgnoreMqtt != false) {
            size += 2 + 1;
          }
          if (ConfigOkToMqtt != false) {
            size += 2 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LoRaConfig other) {
          if (other == null) {
            return;
          }
          if (other.UsePreset != false) {
            UsePreset = other.UsePreset;
          }
          if (other.ModemPreset != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset.LongFast) {
            ModemPreset = other.ModemPreset;
          }
          if (other.Bandwidth != 0) {
            Bandwidth = other.Bandwidth;
          }
          if (other.SpreadFactor != 0) {
            SpreadFactor = other.SpreadFactor;
          }
          if (other.CodingRate != 0) {
            CodingRate = other.CodingRate;
          }
          if (other.FrequencyOffset != 0F) {
            FrequencyOffset = other.FrequencyOffset;
          }
          if (other.Region != global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode.Unset) {
            Region = other.Region;
          }
          if (other.HopLimit != 0) {
            HopLimit = other.HopLimit;
          }
          if (other.TxEnabled != false) {
            TxEnabled = other.TxEnabled;
          }
          if (other.TxPower != 0) {
            TxPower = other.TxPower;
          }
          if (other.ChannelNum != 0) {
            ChannelNum = other.ChannelNum;
          }
          if (other.OverrideDutyCycle != false) {
            OverrideDutyCycle = other.OverrideDutyCycle;
          }
          if (other.Sx126XRxBoostedGain != false) {
            Sx126XRxBoostedGain = other.Sx126XRxBoostedGain;
          }
          if (other.OverrideFrequency != 0F) {
            OverrideFrequency = other.OverrideFrequency;
          }
          if (other.PaFanDisabled != false) {
            PaFanDisabled = other.PaFanDisabled;
          }
          ignoreIncoming_.Add(other.ignoreIncoming_);
          if (other.IgnoreMqtt != false) {
            IgnoreMqtt = other.IgnoreMqtt;
          }
          if (other.ConfigOkToMqtt != false) {
            ConfigOkToMqtt = other.ConfigOkToMqtt;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UsePreset = input.ReadBool();
                break;
              }
              case 16: {
                ModemPreset = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) input.ReadEnum();
                break;
              }
              case 24: {
                Bandwidth = input.ReadUInt32();
                break;
              }
              case 32: {
                SpreadFactor = input.ReadUInt32();
                break;
              }
              case 40: {
                CodingRate = input.ReadUInt32();
                break;
              }
              case 53: {
                FrequencyOffset = input.ReadFloat();
                break;
              }
              case 56: {
                Region = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode) input.ReadEnum();
                break;
              }
              case 64: {
                HopLimit = input.ReadUInt32();
                break;
              }
              case 72: {
                TxEnabled = input.ReadBool();
                break;
              }
              case 80: {
                TxPower = input.ReadInt32();
                break;
              }
              case 88: {
                ChannelNum = input.ReadUInt32();
                break;
              }
              case 96: {
                OverrideDutyCycle = input.ReadBool();
                break;
              }
              case 104: {
                Sx126XRxBoostedGain = input.ReadBool();
                break;
              }
              case 117: {
                OverrideFrequency = input.ReadFloat();
                break;
              }
              case 120: {
                PaFanDisabled = input.ReadBool();
                break;
              }
              case 826:
              case 824: {
                ignoreIncoming_.AddEntriesFrom(input, _repeated_ignoreIncoming_codec);
                break;
              }
              case 832: {
                IgnoreMqtt = input.ReadBool();
                break;
              }
              case 840: {
                ConfigOkToMqtt = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                UsePreset = input.ReadBool();
                break;
              }
              case 16: {
                ModemPreset = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.ModemPreset) input.ReadEnum();
                break;
              }
              case 24: {
                Bandwidth = input.ReadUInt32();
                break;
              }
              case 32: {
                SpreadFactor = input.ReadUInt32();
                break;
              }
              case 40: {
                CodingRate = input.ReadUInt32();
                break;
              }
              case 53: {
                FrequencyOffset = input.ReadFloat();
                break;
              }
              case 56: {
                Region = (global::Meshtastic.Protobufs.Config.Types.LoRaConfig.Types.RegionCode) input.ReadEnum();
                break;
              }
              case 64: {
                HopLimit = input.ReadUInt32();
                break;
              }
              case 72: {
                TxEnabled = input.ReadBool();
                break;
              }
              case 80: {
                TxPower = input.ReadInt32();
                break;
              }
              case 88: {
                ChannelNum = input.ReadUInt32();
                break;
              }
              case 96: {
                OverrideDutyCycle = input.ReadBool();
                break;
              }
              case 104: {
                Sx126XRxBoostedGain = input.ReadBool();
                break;
              }
              case 117: {
                OverrideFrequency = input.ReadFloat();
                break;
              }
              case 120: {
                PaFanDisabled = input.ReadBool();
                break;
              }
              case 826:
              case 824: {
                ignoreIncoming_.AddEntriesFrom(ref input, _repeated_ignoreIncoming_codec);
                break;
              }
              case 832: {
                IgnoreMqtt = input.ReadBool();
                break;
              }
              case 840: {
                ConfigOkToMqtt = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the LoRaConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum RegionCode {
            /// <summary>
            ///
            /// Region is not set
            /// </summary>
            [pbr::OriginalName("UNSET")] Unset = 0,
            /// <summary>
            ///
            /// United States
            /// </summary>
            [pbr::OriginalName("US")] Us = 1,
            /// <summary>
            ///
            /// European Union 433mhz
            /// </summary>
            [pbr::OriginalName("EU_433")] Eu433 = 2,
            /// <summary>
            ///
            /// European Union 868mhz
            /// </summary>
            [pbr::OriginalName("EU_868")] Eu868 = 3,
            /// <summary>
            ///
            /// China
            /// </summary>
            [pbr::OriginalName("CN")] Cn = 4,
            /// <summary>
            ///
            /// Japan
            /// </summary>
            [pbr::OriginalName("JP")] Jp = 5,
            /// <summary>
            ///
            /// Australia / New Zealand
            /// </summary>
            [pbr::OriginalName("ANZ")] Anz = 6,
            /// <summary>
            ///
            /// Korea
            /// </summary>
            [pbr::OriginalName("KR")] Kr = 7,
            /// <summary>
            ///
            /// Taiwan
            /// </summary>
            [pbr::OriginalName("TW")] Tw = 8,
            /// <summary>
            ///
            /// Russia
            /// </summary>
            [pbr::OriginalName("RU")] Ru = 9,
            /// <summary>
            ///
            /// India
            /// </summary>
            [pbr::OriginalName("IN")] In = 10,
            /// <summary>
            ///
            /// New Zealand 865mhz
            /// </summary>
            [pbr::OriginalName("NZ_865")] Nz865 = 11,
            /// <summary>
            ///
            /// Thailand
            /// </summary>
            [pbr::OriginalName("TH")] Th = 12,
            /// <summary>
            ///
            /// WLAN Band
            /// </summary>
            [pbr::OriginalName("LORA_24")] Lora24 = 13,
            /// <summary>
            ///
            /// Ukraine 433mhz
            /// </summary>
            [pbr::OriginalName("UA_433")] Ua433 = 14,
            /// <summary>
            ///
            /// Ukraine 868mhz
            /// </summary>
            [pbr::OriginalName("UA_868")] Ua868 = 15,
            /// <summary>
            ///
            /// Malaysia 433mhz
            /// </summary>
            [pbr::OriginalName("MY_433")] My433 = 16,
            /// <summary>
            ///
            /// Malaysia 919mhz
            /// </summary>
            [pbr::OriginalName("MY_919")] My919 = 17,
            /// <summary>
            ///
            /// Singapore 923mhz
            /// </summary>
            [pbr::OriginalName("SG_923")] Sg923 = 18,
            /// <summary>
            ///
            /// Philippines 433mhz
            /// </summary>
            [pbr::OriginalName("PH_433")] Ph433 = 19,
            /// <summary>
            ///
            /// Philippines 868mhz
            /// </summary>
            [pbr::OriginalName("PH_868")] Ph868 = 20,
            /// <summary>
            ///
            /// Philippines 915mhz
            /// </summary>
            [pbr::OriginalName("PH_915")] Ph915 = 21,
          }

          /// <summary>
          ///
          /// Standard predefined channel settings
          /// Note: these mappings must match ModemPreset Choice in the device code.
          /// </summary>
          public enum ModemPreset {
            /// <summary>
            ///
            /// Long Range - Fast
            /// </summary>
            [pbr::OriginalName("LONG_FAST")] LongFast = 0,
            /// <summary>
            ///
            /// Long Range - Slow
            /// </summary>
            [pbr::OriginalName("LONG_SLOW")] LongSlow = 1,
            /// <summary>
            ///
            /// Very Long Range - Slow
            /// Deprecated in 2.5: Works only with txco and is unusably slow
            /// </summary>
            [global::System.ObsoleteAttribute]
            [pbr::OriginalName("VERY_LONG_SLOW")] VeryLongSlow = 2,
            /// <summary>
            ///
            /// Medium Range - Slow
            /// </summary>
            [pbr::OriginalName("MEDIUM_SLOW")] MediumSlow = 3,
            /// <summary>
            ///
            /// Medium Range - Fast
            /// </summary>
            [pbr::OriginalName("MEDIUM_FAST")] MediumFast = 4,
            /// <summary>
            ///
            /// Short Range - Slow
            /// </summary>
            [pbr::OriginalName("SHORT_SLOW")] ShortSlow = 5,
            /// <summary>
            ///
            /// Short Range - Fast
            /// </summary>
            [pbr::OriginalName("SHORT_FAST")] ShortFast = 6,
            /// <summary>
            ///
            /// Long Range - Moderately Fast
            /// </summary>
            [pbr::OriginalName("LONG_MODERATE")] LongModerate = 7,
            /// <summary>
            ///
            /// Short Range - Turbo
            /// This is the fastest preset and the only one with 500kHz bandwidth.
            /// It is not legal to use in all regions due to this wider bandwidth.
            /// </summary>
            [pbr::OriginalName("SHORT_TURBO")] ShortTurbo = 8,
          }

        }
        #endregion

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class BluetoothConfig : pb::IMessage<BluetoothConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BluetoothConfig> _parser = new pb::MessageParser<BluetoothConfig>(() => new BluetoothConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<BluetoothConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig(BluetoothConfig other) : this() {
          enabled_ = other.enabled_;
          mode_ = other.mode_;
          fixedPin_ = other.fixedPin_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BluetoothConfig Clone() {
          return new BluetoothConfig(this);
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 1;
        private bool enabled_;
        /// <summary>
        ///
        /// Enable Bluetooth on the device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }

        /// <summary>Field number for the "mode" field.</summary>
        public const int ModeFieldNumber = 2;
        private global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode mode_ = global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin;
        /// <summary>
        ///
        /// Determines the pairing strategy for the device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode Mode {
          get { return mode_; }
          set {
            mode_ = value;
          }
        }

        /// <summary>Field number for the "fixed_pin" field.</summary>
        public const int FixedPinFieldNumber = 3;
        private uint fixedPin_;
        /// <summary>
        ///
        /// Specified PIN for PairingMode.FixedPin
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint FixedPin {
          get { return fixedPin_; }
          set {
            fixedPin_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as BluetoothConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(BluetoothConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Enabled != other.Enabled) return false;
          if (Mode != other.Mode) return false;
          if (FixedPin != other.FixedPin) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Enabled != false) hash ^= Enabled.GetHashCode();
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) hash ^= Mode.GetHashCode();
          if (FixedPin != 0) hash ^= FixedPin.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Enabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enabled);
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Mode);
          }
          if (FixedPin != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(FixedPin);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Enabled != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enabled);
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Mode);
          }
          if (FixedPin != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(FixedPin);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Enabled != false) {
            size += 1 + 1;
          }
          if (Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
          }
          if (FixedPin != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FixedPin);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(BluetoothConfig other) {
          if (other == null) {
            return;
          }
          if (other.Enabled != false) {
            Enabled = other.Enabled;
          }
          if (other.Mode != global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode.RandomPin) {
            Mode = other.Mode;
          }
          if (other.FixedPin != 0) {
            FixedPin = other.FixedPin;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Enabled = input.ReadBool();
                break;
              }
              case 16: {
                Mode = (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) input.ReadEnum();
                break;
              }
              case 24: {
                FixedPin = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Enabled = input.ReadBool();
                break;
              }
              case 16: {
                Mode = (global::Meshtastic.Protobufs.Config.Types.BluetoothConfig.Types.PairingMode) input.ReadEnum();
                break;
              }
              case 24: {
                FixedPin = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the BluetoothConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum PairingMode {
            /// <summary>
            ///
            /// Device generates a random PIN that will be shown on the screen of the device for pairing
            /// </summary>
            [pbr::OriginalName("RANDOM_PIN")] RandomPin = 0,
            /// <summary>
            ///
            /// Device requires a specified fixed PIN for pairing
            /// </summary>
            [pbr::OriginalName("FIXED_PIN")] FixedPin = 1,
            /// <summary>
            ///
            /// Device requires no PIN for pairing
            /// </summary>
            [pbr::OriginalName("NO_PIN")] NoPin = 2,
          }

        }
        #endregion

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class SecurityConfig : pb::IMessage<SecurityConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SecurityConfig> _parser = new pb::MessageParser<SecurityConfig>(() => new SecurityConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SecurityConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecurityConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecurityConfig(SecurityConfig other) : this() {
          publicKey_ = other.publicKey_;
          privateKey_ = other.privateKey_;
          adminKey_ = other.adminKey_.Clone();
          isManaged_ = other.isManaged_;
          serialEnabled_ = other.serialEnabled_;
          debugLogApiEnabled_ = other.debugLogApiEnabled_;
          adminChannelEnabled_ = other.adminChannelEnabled_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecurityConfig Clone() {
          return new SecurityConfig(this);
        }

        /// <summary>Field number for the "public_key" field.</summary>
        public const int PublicKeyFieldNumber = 1;
        private pb::ByteString publicKey_ = pb::ByteString.Empty;
        /// <summary>
        ///
        /// The public key of the user's device.
        /// Sent out to other nodes on the mesh to allow them to compute a shared secret key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString PublicKey {
          get { return publicKey_; }
          set {
            publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "private_key" field.</summary>
        public const int PrivateKeyFieldNumber = 2;
        private pb::ByteString privateKey_ = pb::ByteString.Empty;
        /// <summary>
        ///
        /// The private key of the device.
        /// Used to create a shared key with a remote device.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString PrivateKey {
          get { return privateKey_; }
          set {
            privateKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "admin_key" field.</summary>
        public const int AdminKeyFieldNumber = 3;
        private static readonly pb::FieldCodec<pb::ByteString> _repeated_adminKey_codec
            = pb::FieldCodec.ForBytes(26);
        private readonly pbc::RepeatedField<pb::ByteString> adminKey_ = new pbc::RepeatedField<pb::ByteString>();
        /// <summary>
        ///
        /// The public key authorized to send admin messages to this node.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<pb::ByteString> AdminKey {
          get { return adminKey_; }
        }

        /// <summary>Field number for the "is_managed" field.</summary>
        public const int IsManagedFieldNumber = 4;
        private bool isManaged_;
        /// <summary>
        ///
        /// If true, device is considered to be "managed" by a mesh administrator via admin messages
        /// Device is managed by a mesh administrator.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsManaged {
          get { return isManaged_; }
          set {
            isManaged_ = value;
          }
        }

        /// <summary>Field number for the "serial_enabled" field.</summary>
        public const int SerialEnabledFieldNumber = 5;
        private bool serialEnabled_;
        /// <summary>
        ///
        /// Serial Console over the Stream API."
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SerialEnabled {
          get { return serialEnabled_; }
          set {
            serialEnabled_ = value;
          }
        }

        /// <summary>Field number for the "debug_log_api_enabled" field.</summary>
        public const int DebugLogApiEnabledFieldNumber = 6;
        private bool debugLogApiEnabled_;
        /// <summary>
        ///
        /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
        /// Output live debug logging over serial or bluetooth is set to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DebugLogApiEnabled {
          get { return debugLogApiEnabled_; }
          set {
            debugLogApiEnabled_ = value;
          }
        }

        /// <summary>Field number for the "admin_channel_enabled" field.</summary>
        public const int AdminChannelEnabledFieldNumber = 8;
        private bool adminChannelEnabled_;
        /// <summary>
        ///
        /// Allow incoming device control over the insecure legacy admin channel.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AdminChannelEnabled {
          get { return adminChannelEnabled_; }
          set {
            adminChannelEnabled_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SecurityConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SecurityConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PublicKey != other.PublicKey) return false;
          if (PrivateKey != other.PrivateKey) return false;
          if(!adminKey_.Equals(other.adminKey_)) return false;
          if (IsManaged != other.IsManaged) return false;
          if (SerialEnabled != other.SerialEnabled) return false;
          if (DebugLogApiEnabled != other.DebugLogApiEnabled) return false;
          if (AdminChannelEnabled != other.AdminChannelEnabled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (PublicKey.Length != 0) hash ^= PublicKey.GetHashCode();
          if (PrivateKey.Length != 0) hash ^= PrivateKey.GetHashCode();
          hash ^= adminKey_.GetHashCode();
          if (IsManaged != false) hash ^= IsManaged.GetHashCode();
          if (SerialEnabled != false) hash ^= SerialEnabled.GetHashCode();
          if (DebugLogApiEnabled != false) hash ^= DebugLogApiEnabled.GetHashCode();
          if (AdminChannelEnabled != false) hash ^= AdminChannelEnabled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (PublicKey.Length != 0) {
            output.WriteRawTag(10);
            output.WriteBytes(PublicKey);
          }
          if (PrivateKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(PrivateKey);
          }
          adminKey_.WriteTo(output, _repeated_adminKey_codec);
          if (IsManaged != false) {
            output.WriteRawTag(32);
            output.WriteBool(IsManaged);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(40);
            output.WriteBool(SerialEnabled);
          }
          if (DebugLogApiEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(DebugLogApiEnabled);
          }
          if (AdminChannelEnabled != false) {
            output.WriteRawTag(64);
            output.WriteBool(AdminChannelEnabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (PublicKey.Length != 0) {
            output.WriteRawTag(10);
            output.WriteBytes(PublicKey);
          }
          if (PrivateKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(PrivateKey);
          }
          adminKey_.WriteTo(ref output, _repeated_adminKey_codec);
          if (IsManaged != false) {
            output.WriteRawTag(32);
            output.WriteBool(IsManaged);
          }
          if (SerialEnabled != false) {
            output.WriteRawTag(40);
            output.WriteBool(SerialEnabled);
          }
          if (DebugLogApiEnabled != false) {
            output.WriteRawTag(48);
            output.WriteBool(DebugLogApiEnabled);
          }
          if (AdminChannelEnabled != false) {
            output.WriteRawTag(64);
            output.WriteBool(AdminChannelEnabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (PublicKey.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
          }
          if (PrivateKey.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(PrivateKey);
          }
          size += adminKey_.CalculateSize(_repeated_adminKey_codec);
          if (IsManaged != false) {
            size += 1 + 1;
          }
          if (SerialEnabled != false) {
            size += 1 + 1;
          }
          if (DebugLogApiEnabled != false) {
            size += 1 + 1;
          }
          if (AdminChannelEnabled != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SecurityConfig other) {
          if (other == null) {
            return;
          }
          if (other.PublicKey.Length != 0) {
            PublicKey = other.PublicKey;
          }
          if (other.PrivateKey.Length != 0) {
            PrivateKey = other.PrivateKey;
          }
          adminKey_.Add(other.adminKey_);
          if (other.IsManaged != false) {
            IsManaged = other.IsManaged;
          }
          if (other.SerialEnabled != false) {
            SerialEnabled = other.SerialEnabled;
          }
          if (other.DebugLogApiEnabled != false) {
            DebugLogApiEnabled = other.DebugLogApiEnabled;
          }
          if (other.AdminChannelEnabled != false) {
            AdminChannelEnabled = other.AdminChannelEnabled;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                PublicKey = input.ReadBytes();
                break;
              }
              case 18: {
                PrivateKey = input.ReadBytes();
                break;
              }
              case 26: {
                adminKey_.AddEntriesFrom(input, _repeated_adminKey_codec);
                break;
              }
              case 32: {
                IsManaged = input.ReadBool();
                break;
              }
              case 40: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 48: {
                DebugLogApiEnabled = input.ReadBool();
                break;
              }
              case 64: {
                AdminChannelEnabled = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                PublicKey = input.ReadBytes();
                break;
              }
              case 18: {
                PrivateKey = input.ReadBytes();
                break;
              }
              case 26: {
                adminKey_.AddEntriesFrom(ref input, _repeated_adminKey_codec);
                break;
              }
              case 32: {
                IsManaged = input.ReadBool();
                break;
              }
              case 40: {
                SerialEnabled = input.ReadBool();
                break;
              }
              case 48: {
                DebugLogApiEnabled = input.ReadBool();
                break;
              }
              case 64: {
                AdminChannelEnabled = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// Blank config request, strictly for getting the session key
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class SessionkeyConfig : pb::IMessage<SessionkeyConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SessionkeyConfig> _parser = new pb::MessageParser<SessionkeyConfig>(() => new SessionkeyConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SessionkeyConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Meshtastic.Protobufs.Config.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SessionkeyConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SessionkeyConfig(SessionkeyConfig other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SessionkeyConfig Clone() {
          return new SessionkeyConfig(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SessionkeyConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SessionkeyConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SessionkeyConfig other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
